
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>zfit.core.space &#8212; zfit 0.5.5.dev15+g8c8efe1 documentation</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.d431a4ee1c1efae0e38bdfebc22debff.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.30270b6e4c972e43c488.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/zfit-favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    
    <a class="navbar-brand" href="../../../index.html">
      <img src="../../../_static/zfit-logo-light_400x168.png" class="logo" alt="logo">
    </a>
    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../whats_new/index.html">Whatâ€™s new?</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../getting_started/index.html">Getting started</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../user_api/index.html">API reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../project/index.html">Project</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../ask_a_question.html">Ask a question</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/zfit/zfit" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar">

<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search zfit..." aria-label="Search zfit..." autocomplete="off" >
</form>


<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

  <div class="bd-toc-item active">
  

  <ul class="nav bd-sidenav">
      
      
      
      
      
      
      
      
      
      
      
    </ul>

</nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for zfit.core.space</h1><div class="highlight"><pre>
<span></span><span class="c1">#  Copyright (c) 2020 zfit</span>

<span class="c1"># TODO(Mayou36): update docs above</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util.deprecation</span> <span class="kn">import</span> <span class="n">deprecated</span>

<span class="kn">import</span> <span class="nn">zfit</span>
<span class="kn">from</span> <span class="nn">.baseobject</span> <span class="kn">import</span> <span class="n">BaseObject</span>
<span class="kn">from</span> <span class="nn">.coordinates</span> <span class="kn">import</span> <span class="n">Coordinates</span><span class="p">,</span> <span class="n">_convert_obs_to_str</span><span class="p">,</span> <span class="n">convert_to_axes</span><span class="p">,</span> <span class="n">convert_to_obs_str</span>
<span class="kn">from</span> <span class="nn">.dimension</span> <span class="kn">import</span> <span class="n">common_obs</span><span class="p">,</span> <span class="n">common_axes</span><span class="p">,</span> <span class="n">limits_overlap</span>
<span class="kn">from</span> <span class="nn">.interfaces</span> <span class="kn">import</span> <span class="n">ZfitLimit</span><span class="p">,</span> <span class="n">ZfitOrderableDimensional</span><span class="p">,</span> <span class="n">ZfitSpace</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">z</span>
<span class="kn">from</span> <span class="nn">..settings</span> <span class="kn">import</span> <span class="n">ztypes</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">ztyping</span>
<span class="kn">from</span> <span class="nn">..util.container</span> <span class="kn">import</span> <span class="n">convert_to_container</span>
<span class="kn">from</span> <span class="nn">..util.exception</span> <span class="kn">import</span> <span class="p">(</span><span class="n">AxesNotSpecifiedError</span><span class="p">,</span> <span class="n">IntentionAmbiguousError</span><span class="p">,</span> <span class="n">LimitsUnderdefinedError</span><span class="p">,</span>
                              <span class="n">MultipleLimitsNotImplementedError</span><span class="p">,</span> <span class="n">NormRangeNotImplementedError</span><span class="p">,</span> <span class="n">ObsNotSpecifiedError</span><span class="p">,</span>
                              <span class="n">OverdefinedError</span><span class="p">,</span> <span class="n">BreakingAPIChangeError</span><span class="p">,</span> <span class="n">LimitsIncompatibleError</span><span class="p">,</span> <span class="n">SpaceIncompatibleError</span><span class="p">,</span>
                              <span class="n">ObsIncompatibleError</span><span class="p">,</span> <span class="n">AxesIncompatibleError</span><span class="p">,</span> <span class="n">ShapeIncompatibleError</span><span class="p">,</span>
                              <span class="n">IllegalInGraphModeError</span><span class="p">,</span> <span class="n">CoordinatesUnderdefinedError</span><span class="p">,</span> <span class="n">CoordinatesIncompatibleError</span><span class="p">,</span>
                              <span class="n">InvalidLimitSubspaceError</span><span class="p">,</span> <span class="n">CannotConvertToNumpyError</span><span class="p">,</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">,</span>
                              <span class="n">NumberOfEventsIncompatibleError</span><span class="p">)</span>


<div class="viewcode-block" id="LimitRangeDefinition"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.LimitRangeDefinition">[docs]</a><span class="k">class</span> <span class="nc">LimitRangeDefinition</span><span class="p">:</span>
    <span class="k">pass</span></div>


<span class="c1"># Singleton</span>
<div class="viewcode-block" id="Any"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Any">[docs]</a><span class="k">class</span> <span class="nc">Any</span><span class="p">(</span><span class="n">LimitRangeDefinition</span><span class="p">):</span>
    <span class="n">_singleton_instance</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_singleton_instance</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_singleton_instance</span> <span class="o">=</span> <span class="n">instance</span>

        <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_singleton_instance</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># each subclass is a singleton of &quot;itself&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Any&gt;&#39;</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># def __eq__(self, other):</span>
    <span class="c1">#     return True</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="c1"># def __hash__(self):</span>
    <span class="c1">#     return hash(id(self))</span>


<div class="viewcode-block" id="AnyLower"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.AnyLower">[docs]</a><span class="k">class</span> <span class="nc">AnyLower</span><span class="p">(</span><span class="n">Any</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Any Lower Limit&gt;&#39;</span></div>

    <span class="c1"># def __eq__(self, other):</span>
    <span class="c1">#     return False</span>

    <span class="c1"># def __ge__(self, other):</span>
    <span class="c1">#     return False</span>
    <span class="c1">#</span>
    <span class="c1"># def __gt__(self, other):</span>
    <span class="c1">#     return False</span>


<div class="viewcode-block" id="AnyUpper"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.AnyUpper">[docs]</a><span class="k">class</span> <span class="nc">AnyUpper</span><span class="p">(</span><span class="n">Any</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Any Upper Limit&gt;&#39;</span></div>

    <span class="c1"># def __eq__(self, other):</span>
    <span class="c1">#     return False</span>

    <span class="c1"># def __le__(self, other):</span>
    <span class="c1">#     return False</span>
    <span class="c1">#</span>
    <span class="c1"># def __lt__(self, other):</span>
    <span class="c1">#     return False</span>


<span class="n">ANY</span> <span class="o">=</span> <span class="n">Any</span><span class="p">()</span>
<span class="n">ANY_LOWER</span> <span class="o">=</span> <span class="n">AnyLower</span><span class="p">()</span>
<span class="n">ANY_UPPER</span> <span class="o">=</span> <span class="n">AnyUpper</span><span class="p">()</span>


<span class="c1"># TODO(warning): set a changeable warning system in zfit</span>
<div class="viewcode-block" id="warn_or_fail_not_rect"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.warn_or_fail_not_rect">[docs]</a><span class="k">def</span> <span class="nf">warn_or_fail_not_rect</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">warned</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">wrapped_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot call </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> as the space </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has functional,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; not rectangular limits. Use `rect_*` functions to obtain the&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; rectangular limits/area or `inside`/`filter` to test if values are&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; inside of the space.&quot;</span><span class="p">)</span>
        <span class="k">nonlocal</span> <span class="n">warned</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">warned</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The function </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> may does not return the actual area/limits&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; but rather the rectangular limits. </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> can also have functional&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; limits that are arbitrarily defined and lay inside the rect_limits.&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; To test if a value is inside, use `inside` or `filter`.&quot;</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">warned</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_func</span></div>


<span class="nd">@z</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">wraps</span><span class="o">=</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">experimental_relax_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">calculate_rect_area</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">):</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">rect_limits</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_prod</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area</span>


<span class="nd">@z</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">wraps</span><span class="o">=</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">experimental_relax_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inside_rect_limits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rect_limits</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x has ndims &lt;= 1, which is most probably not wanted. The default shape for array-like&quot;</span>
                         <span class="s2">&quot; structures is (nevents, n_obs).&quot;</span><span class="p">)</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstack_x</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="n">below_upper</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">input_tensor</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># if all obs inside</span>
    <span class="n">above_lower</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">input_tensor</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">above_lower</span><span class="p">,</span> <span class="n">below_upper</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inside</span>


<span class="nd">@z</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">wraps</span><span class="o">=</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">experimental_relax_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_rect_limits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rect_limits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">inside_rect_limits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>


<div class="viewcode-block" id="convert_to_tensor_or_numpy"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.convert_to_tensor_or_numpy">[docs]</a><span class="k">def</span> <span class="nf">convert_to_tensor_or_numpy</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ztypes</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">contains_tensor</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">as_numpy_dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_sanitize_x_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x has ndims &lt;= 1, which is most probably not wanted. The default shape for array-like&quot;</span>
                         <span class="s2">&quot; structures is (nevents, n_obs).&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_obs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_static_value</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">n_obs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ShapeIncompatibleError</span><span class="p">(</span><span class="s2">&quot;n_obs and the last dim of x do not agree. Assuming x has shape (..., n_obs)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="is_range_definition"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.is_range_definition">[docs]</a><span class="k">def</span> <span class="nf">is_range_definition</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">LimitRangeDefinition</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">limit</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tf</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_range_definition</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span> <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="n">limit</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># not iterable and was not a LimitRangeDefinition in the beginning</span></div>


<div class="viewcode-block" id="Limit"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit">[docs]</a><span class="k">class</span> <span class="nc">Limit</span><span class="p">(</span><span class="n">ZfitLimit</span><span class="p">):</span>
    <span class="n">_experimental_allow_vectors</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_fn</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsFuncTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">rect_limits</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_obs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify a limit with rectangular limits (and possiblty an arbitrary function).</span>

<span class="sd">        Args:</span>
<span class="sd">            limit_fn: Function that works as `inside`: return true if a point is inside of the limits.</span>
<span class="sd">                The function should take one tensor-like argument with shape (..., n_obs) and should return</span>
<span class="sd">                a shape without the last dimension.</span>
<span class="sd">            rect_limits: Rectangular limits, a tuple of tensor-like objects with shape (typically) (1, n_obs) or similar</span>
<span class="sd">                such as only a tuple/list of values that will be interpreted as the last dimension. They should cover an</span>
<span class="sd">                area that includes `limit_fn` fully.</span>
<span class="sd">            n_obs: dimensionality of the Limits, the last dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">limit_fn</span><span class="p">,</span> <span class="n">rect_limits</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">,</span> <span class="n">is_rect</span><span class="p">,</span> <span class="n">sublimits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convert_input_limits</span><span class="p">(</span><span class="n">limit_fn</span><span class="o">=</span><span class="n">limit_fn</span><span class="p">,</span>
                                                                                            <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">,</span>
                                                                                            <span class="n">n_obs</span><span class="o">=</span><span class="n">n_obs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limit_fn</span> <span class="o">=</span> <span class="n">limit_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits</span> <span class="o">=</span> <span class="n">rect_limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_obs</span> <span class="o">=</span> <span class="n">n_obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rect</span> <span class="o">=</span> <span class="n">is_rect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sublimits</span> <span class="o">=</span> <span class="n">sublimits</span>

    <span class="k">def</span> <span class="nf">_check_convert_input_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_fn</span><span class="p">,</span> <span class="n">rect_limits</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit_fn</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit_fn</span><span class="p">,</span> <span class="n">Limit</span><span class="p">):</span>  <span class="c1"># because of the limit_fn, that is private. Maybe use `inside` instead?</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;If limits_fn is an instance of ZfitLimit, it has to be an instance of Limit (currently)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rect_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_obs</span> <span class="o">!=</span> <span class="n">limit_fn</span><span class="o">.</span><span class="n">n_obs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">OverdefinedError</span><span class="p">(</span><span class="s2">&quot;limits_fn is a ZfitLimit. rect_limits and n_obs must not be specified&quot;</span>
                                       <span class="s2">&quot;(or n_obs coincide).&quot;</span><span class="p">)</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limit_fn</span>

            <span class="n">limit_fn</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">limit_fn</span>
            <span class="n">rect_limits</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">rect_limits</span>
            <span class="n">n_obs</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">n_obs</span>
            <span class="c1"># return limit._limit_fn, limit.rect_limits, limit.n_obs, limit.has_rect_limits, (self,)</span>
        <span class="n">limits_are_rect</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># if the limits are False or None, we can take a shortcut and don&#39;t need to do any preprocessing</span>
        <span class="n">return_limits_short</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">limit_fn</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rect_limits</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">limits_short</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">return_limits_short</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">limit_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rect_limits</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">limits_short</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">return_limits_short</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">rect_limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">limits_short</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">return_limits_short</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># start from limits are anything, rect is None</span>
                <span class="n">limit_fn</span> <span class="o">=</span> <span class="n">rect_limits</span>
                <span class="n">rect_limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">return_limits_short</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sublimits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">limit_fn</span><span class="o">=</span><span class="n">limits_short</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sublimits</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">limits_short</span><span class="p">,</span> <span class="n">limits_short</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">,</span> <span class="n">limits_short</span><span class="p">,</span> <span class="n">sublimits</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">limit_fn</span><span class="p">):</span>  <span class="c1"># limits_fn is actually rect_limits</span>
            <span class="n">rect_limits</span> <span class="o">=</span> <span class="n">limit_fn</span>
            <span class="n">limit_fn</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits_are_rect</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">rect_limits</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Limits given as a function need also rect_limits, cannot be None or False&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">rect_limits</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The outermost shape of `rect_limits` has to be 2 to represent (lower, upper).&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_rect_limit</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_rect_limit</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

        <span class="c1"># vectors means more than one n_events, in the first dim</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_experimental_allow_vectors</span><span class="p">:</span>
            <span class="n">lower_nevents</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_static_value</span><span class="p">(</span><span class="n">lower</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">upper_nevents</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_static_value</span><span class="p">(</span><span class="n">upper</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">lower_nevents</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">upper_nevents</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LimitsIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Vectors (limits with n_events != 1) are not allowed. Experimental&quot;</span>
                                              <span class="s2">&quot; flag (_experimental_allow_vectors) can be switched on if desired.&quot;</span>
                                              <span class="s2">&quot; This happened most likely due to the new Space limits layout:&quot;</span>
                                              <span class="s2">&quot; To create multiple limits, use the addition operator of simple spaces.&quot;</span><span class="p">)</span>

        <span class="n">lower_nobs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_static_value</span><span class="p">(</span><span class="n">lower</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">upper_nobs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_static_value</span><span class="p">(</span><span class="n">upper</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">lower_nobs</span> <span class="o">==</span> <span class="n">upper_nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeIncompatibleError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Last dimension of lower (</span><span class="si">{</span><span class="n">lower_nobs</span><span class="si">}</span><span class="s2">) and upper (</span><span class="si">{</span><span class="n">upper_nobs</span><span class="si">}</span><span class="s2">) have to coincide.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lower_nobs</span> <span class="o">==</span> <span class="n">n_obs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeIncompatibleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inferred last dimension (</span><span class="si">{</span><span class="n">lower_nobs</span><span class="si">}</span><span class="s2">) does not coincide with &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;given n_obs (</span><span class="si">{</span><span class="n">n_obs</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_range_definition</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)):</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">assert_greater</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;All upper limits have to be larger than the lower limits and are&quot;</span>
                                                    <span class="s2">&quot; given as (lower, upper). Maybe (upper, lower) was entered?&quot;</span><span class="p">)</span>

        <span class="n">n_obs</span> <span class="o">=</span> <span class="n">lower_nobs</span>  <span class="c1"># in case it was None</span>
        <span class="n">rect_limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="c1"># It can be that there is a function that depends on multiple dimensions, e.g. if we have</span>
        <span class="c1"># a `limit_fn` and n_obs &gt; 1. But if we have only rectangular limits, we can split them up</span>
        <span class="c1"># which allows later (the Space) to better combine and get subspaces</span>

        <span class="c1"># create sublimits to iterate if possible</span>
        <span class="n">sublimits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">limits_are_rect</span> <span class="ow">and</span> <span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">up</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">sublimits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">rect_limits</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">up</span><span class="p">),</span> <span class="n">n_obs</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sublimits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">sublimits</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sublimits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">limit_fn</span><span class="p">,</span> <span class="n">rect_limits</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">,</span> <span class="n">limits_are_rect</span><span class="p">,</span> <span class="n">sublimits</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sanitize_rect_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLowerReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sanitize the input limit and return if it is numerical or not.</span>

<span class="sd">        Args:</span>
<span class="sd">            limit:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_range_definition</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>  <span class="c1"># as the above ANY</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">ztypes</span><span class="o">.</span><span class="n">float</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">convert_to_tensor_or_numpy</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">limit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If the limits are rectangular.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rect</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the rectangular limits as `np.ndarray``tf.Tensor` if they are set and not false.</span>

<span class="sd">            The rectangular limits can be used for sampling. They do not in general represent the limits</span>
<span class="sd">            of the object as a functional limit can be set and to check if something is inside the limits,</span>
<span class="sd">            the method :py:meth:`~Limit.inside` should be used.</span>

<span class="sd">            In order to test if the limits are False or None, it is recommended to use the appropriate methods</span>
<span class="sd">            `limits_are_false` and `limits_are_set`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lower and upper limits.</span>
<span class="sd">        Raises:</span>
<span class="sd">            LimitsNotSpecifiedError: If there are not limits set or they are False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limits are False or not set, cannot return the rectangular limits.&quot;</span><span class="p">)</span>
        <span class="n">rect_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits</span>
        <span class="k">return</span> <span class="n">rect_limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_rect_limits_tf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsTFReturnType</span><span class="p">:</span>
        <span class="n">rect_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits</span>
        <span class="k">if</span> <span class="n">rect_limits</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rect_limits</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">((</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits_np</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsNPReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the rectangular limits as `np.ndarray`. Raise error if not possible.</span>

<span class="sd">        Rectangular limits are returned as numpy arrays which can be useful when doing checks that do not</span>
<span class="sd">        need to be involved in the computation later on as they allow direct interaction with Python as</span>
<span class="sd">        compared to `tf.Tensor` inside a graph function.</span>


<span class="sd">        Returns:</span>
<span class="sd">            A tuple of two `np.ndarray` with shape (1, n_obs) typically. The last</span>
<span class="sd">                dimension is always `n_obs`, the first can be vectorized. This allows unstacking</span>
<span class="sd">                with `z.unstack_x()` as can be done with data.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CannotConvertToNumpyError: In case the conversion fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits</span>

        <span class="n">lower</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">_try_convert_numpy</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">_try_convert_numpy</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLowerReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The lower, rectangular limits, equivalent to `rect_limits[0] with shape (..., n_obs)`</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lower, rectangular limits as `np.ndarray` or `tf.Tensor`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectUpperReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The upper, rectangular limits, equivalent to `rect_limits[1]` with shape (..., n_obs)</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lower, rectangular limits as `np.ndarray` or `tf.Tensor`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Limit.rect_area"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.rect_area">[docs]</a>    <span class="k">def</span> <span class="nf">rect_area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the total rectangular area of all the limits and axes. Useful, for example, for MC integration.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calculate_rect_area</span><span class="p">(</span><span class="n">rect_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits_tf</span><span class="p">)</span></div>

<div class="viewcode-block" id="Limit.inside"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.inside">[docs]</a>    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeInput</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeReturnNoData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Test if `x` is inside the limits.</span>

<span class="sd">        This function should be used to test if values are inside the limits. If the given x is already inside</span>
<span class="sd">        the rectangular limits, e.g. because it was sampled from within them</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Values to be checked whether they are inside of the limits. The shape is expected to have the last</span>
<span class="sd">                dimension equal to n_obs.</span>
<span class="sd">            guarantee_limits: Guarantee that the values are already inside the rectangular limits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Return a boolean tensor-like object with the same shape as the input `x` except of the</span>
<span class="sd">                last dimension removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_sanitize_x_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">(</span><span class="s2">&quot;Cannot call `inside` without limits defined.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">guarantee_limits</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">guarantee_limits</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inside_rect_limits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits_tf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="Limit.filter"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeInput</span><span class="p">,</span>
               <span class="n">guarantee_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeReturnNoData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter `x` by removing the elements along `axis` that are not inside the limits.</span>

<span class="sd">        This is similar to `tf.boolean_mask`.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Values to be checked whether they are inside of the limits. If not, the corresonding element (in the</span>
<span class="sd">                specified `axis`) is removed. The shape is expected to have the last dimension equal to n_obs.</span>
<span class="sd">            guarantee_limits: Guarantee that the values are already inside the rectangular limits.</span>
<span class="sd">            axis: The axis to remove the elements from. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Return an object with the same shape as `x` except that along `axis` elements have been</span>
<span class="sd">                removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">(</span><span class="s2">&quot;Cannot call `filter` without limits defined.&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_sanitize_x_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>

        <span class="c1"># shortcut, everything already inside</span>
        <span class="k">if</span> <span class="n">guarantee_limits</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="o">=</span><span class="n">guarantee_limits</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limit_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit_fn</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits_are_tensors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True if the rectangular limits are tensors.</span>

<span class="sd">        If a limit with tensors is evaluated inside a graph context, comparison operations will fail.</span>

<span class="sd">        Returns:</span>
<span class="sd">            If the rectangular limits are tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits_np</span>
        <span class="k">except</span> <span class="n">CannotConvertToNumpyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits_are_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If the limits have never explicitly been set to a limit or to False.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits_are_false</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If the limits have been set to False, so the object on purpose does not contain limits.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits</span> <span class="ow">is</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If there are limits set and they are not false.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits_are_false</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dimensionality, the number of observables, of the limits. Equals to the last axis in rectangular limits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dimensionality of the limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_obs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            Return the number of events, the dimension of the first shape. If this is &gt; 1 or None,</span>
<span class="sd">                it&#39;s vectorized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_lower</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Limit.equal"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">allow_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Compare the limits on equality. For ANY objects, this also returns true.</span>

<span class="sd">        If called inside a graph context *and* the limits are tensors, this will return a symbolic `tf.Tensor`.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: Any other object to compare with</span>
<span class="sd">            allow_graph: If False and the function returns a symbolic tensor, raise IllegalInGraphModeError instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a Python boolean or a `tf.Tensor`</span>
<span class="sd">         Raises:</span>
<span class="sd">             IllegalInGraphModeError: if `allow_graph`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">equal_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="n">allow_graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="Limit.__eq__"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compares two Limits for equality without graph mode allowed.</span>

<span class="sd">        Returns:</span>

<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

        <span class="c1"># TODO: use below?</span>
        <span class="c1"># try:</span>
        <span class="c1">#     return self.equal(other, allow_graph=False)</span>
        <span class="c1"># except IllegalInGraphModeError:</span>
        <span class="c1">#     warnings.warn(f&quot;Comparing instances ({self, other}) in graph mode (space/limit) contains Tensor. This returns&quot;</span>
        <span class="c1">#                   &quot; identity tests. To prevent this, use numpy objects, not tensors, for limits if not needed.&quot;)</span>
        <span class="c1">#     return self is other</span>

<div class="viewcode-block" id="Limit.less_equal"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.less_equal">[docs]</a>    <span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span>
                   <span class="n">allow_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Set-like comparison for compatibility. If an object is less_equal to another, the limits are combatible.</span>

<span class="sd">        This can be used to determine whether a fitting range specification can handle another limit.</span>

<span class="sd">        If called inside a graph context *and* the limits are tensors, this will return a symbolic `tf.Tensor`.</span>


<span class="sd">        Args:</span>
<span class="sd">            other: Any other object to compare with</span>
<span class="sd">            allow_graph: If False and the function returns a symbolic tensor, raise IllegalInGraphModeError instead.</span>


<span class="sd">        Returns:</span>
<span class="sd">            Result of the comparison</span>
<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">less_equal_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="n">allow_graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="Limit.__le__"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.__le__">[docs]</a>    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set-like comparison for compatibility. If an object is less_equal to another, the limits are combatible.</span>

<span class="sd">        This can be used to determine whether a fitting range specification can handle another limit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Result of the comparison</span>
<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Limit.get_sublimits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.Limit.get_sublimits">[docs]</a>    <span class="k">def</span> <span class="nf">get_sublimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ZfitLimit</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Splits itself into multiple sublimits with smaller n_obs.</span>

<span class="sd">        If this is not possible, if the limits are not rectangular, just returns itself.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The sublimits if it was able to split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sublimits</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limit_fn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>  <span class="c1"># not rect limits, not hashable and unprecise</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_false</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="s1">&#39;rectangular&#39;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;zfit </span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2"> rect_limits=</span><span class="si">{</span><span class="n">limits</span><span class="si">}</span><span class="s2">, limit_fn=</span><span class="si">{</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="si">}</span><span class="s2">&gt;&quot;</span></div>


<div class="viewcode-block" id="rect_limits_are_any"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.rect_limits_are_any">[docs]</a><span class="k">def</span> <span class="nf">rect_limits_are_any</span><span class="p">(</span><span class="n">limit</span><span class="p">:</span> <span class="n">ZfitLimit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;True if all limits in limit are ANY objects.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limit</span><span class="o">.</span><span class="n">rect_limits_are_tensors</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="n">limit</span><span class="o">.</span><span class="n">rect_limits_np</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">lim</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="less_equal_limits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.less_equal_limits">[docs]</a><span class="k">def</span> <span class="nf">less_equal_limits</span><span class="p">(</span><span class="n">limit1</span><span class="p">:</span> <span class="n">Limit</span><span class="p">,</span> <span class="n">limit2</span><span class="p">:</span> <span class="n">Limit</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">rect_limits_are_any</span><span class="p">(</span><span class="n">limit1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rect_limits_are_any</span><span class="p">(</span><span class="n">limit2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">lower1</span><span class="p">,</span> <span class="n">upper1</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">rect_limits_np</span>
        <span class="n">lower2</span><span class="p">,</span> <span class="n">upper2</span> <span class="o">=</span> <span class="n">limit2</span><span class="o">.</span><span class="n">rect_limits_np</span>
    <span class="k">except</span> <span class="n">CannotConvertToNumpyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_graph</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">IllegalInGraphModeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use equality in graph mode, e.g. inside a `tf.function` decorated &quot;</span>
                <span class="s2">&quot;function. To retrieve a symbolic Tensor, use `.equal(..., allow_graph=True)`&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower1</span><span class="p">,</span> <span class="n">upper1</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">rect_limits</span>
            <span class="n">lower2</span><span class="p">,</span> <span class="n">upper2</span> <span class="o">=</span> <span class="n">limit2</span><span class="o">.</span><span class="n">rect_limits</span>

    <span class="n">lower_le</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">lower1</span><span class="p">,</span> <span class="n">lower2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">upper_le</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">upper1</span><span class="p">,</span> <span class="n">upper2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rect_limits_le</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lower_le</span><span class="p">,</span> <span class="n">upper_le</span><span class="p">)</span>
    <span class="c1"># if both are functional, they have to coincide</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">limit1</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="ow">or</span> <span class="n">limit2</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">):</span>
        <span class="n">funcs_equal</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">limit_fn</span> <span class="o">==</span> <span class="n">limit2</span><span class="o">.</span><span class="n">limit_fn</span>

    <span class="c1"># if one is functional, one is rect: the bigger one can be rect</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">limit1</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="ow">and</span> <span class="n">limit2</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
        <span class="n">funcs_equal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">funcs_equal</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">limit_fn</span> <span class="o">==</span> <span class="n">limit2</span><span class="o">.</span><span class="n">limit_fn</span>
    <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">rect_limits_le</span><span class="p">,</span> <span class="n">funcs_equal</span><span class="p">)</span></div>


<div class="viewcode-block" id="equal_limits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.equal_limits">[docs]</a><span class="k">def</span> <span class="nf">equal_limits</span><span class="p">(</span><span class="n">limit1</span><span class="p">:</span> <span class="n">Limit</span><span class="p">,</span> <span class="n">limit2</span><span class="p">:</span> <span class="n">Limit</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># if both are functional, we just need to compare their functions; the rect limits are &quot;irrelevant&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">limit1</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="ow">or</span> <span class="n">limit2</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">limit1</span><span class="o">.</span><span class="n">limit_fn</span> <span class="o">==</span> <span class="n">limit2</span><span class="o">.</span><span class="n">limit_fn</span>

    <span class="c1"># if one is functional, one is rect: they are not the same</span>
    <span class="k">elif</span> <span class="n">limit1</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="o">^</span> <span class="n">limit2</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">rect_limits_np</span>
        <span class="n">lower_other</span><span class="p">,</span> <span class="n">upper_other</span> <span class="o">=</span> <span class="n">limit2</span><span class="o">.</span><span class="n">rect_limits_np</span>
    <span class="k">except</span> <span class="n">CannotConvertToNumpyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_graph</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">IllegalInGraphModeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use equality in graph mode, e.g. inside a `tf.function` decorated &quot;</span>
                <span class="s2">&quot;function. To retrieve a symbolic Tensor, use `.equal(..., allow_graph=True)`&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">rect_limits</span>
            <span class="n">lower_other</span><span class="p">,</span> <span class="n">upper_other</span> <span class="o">=</span> <span class="n">limit2</span><span class="o">.</span><span class="n">rect_limits</span>

    <span class="c1"># TODO add tolerances</span>
    <span class="n">lower_limits_equal</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">allclose_anyaware</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">lower_other</span><span class="p">))</span>
    <span class="n">upper_limits_equal</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">allclose_anyaware</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">upper_other</span><span class="p">))</span>
    <span class="n">rect_limits_equal</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lower_limits_equal</span><span class="p">,</span> <span class="n">upper_limits_equal</span><span class="p">)</span>
    <span class="n">funcs_equal</span> <span class="o">=</span> <span class="n">limit1</span><span class="o">.</span><span class="n">limit_fn</span> <span class="o">==</span> <span class="n">limit2</span><span class="o">.</span><span class="n">limit_fn</span>
    <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">rect_limits_equal</span><span class="p">,</span> <span class="n">funcs_equal</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseSpace"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace">[docs]</a><span class="k">class</span> <span class="nc">BaseSpace</span><span class="p">(</span><span class="n">ZfitSpace</span><span class="p">,</span> <span class="n">BaseObject</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">Coordinates</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>

<div class="viewcode-block" id="BaseSpace.inside"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.inside">[docs]</a>    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeInput</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Test if `x` is inside the limits.</span>

<span class="sd">        This function should be used to test if values are inside the limits. If the given x is already inside</span>
<span class="sd">        the rectangular limits, e.g. because it was sampled from within them</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Values to be checked whether they are inside of the limits. The shape is expected to have the last</span>
<span class="sd">                dimension equal to n_obs.</span>
<span class="sd">            guarantee_limits: Guarantee that the values are already inside the rectangular limits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Return a boolean tensor-like object with the same shape as the input `x` except of the</span>
<span class="sd">                last dimension removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_sanitize_x_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="ow">and</span> <span class="n">guarantee_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inside</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="BaseSpace.filter"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeInput</span><span class="p">,</span>
               <span class="n">guarantee_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeReturnNoData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter `x` by removing the elements along `axis` that are not inside the limits.</span>

<span class="sd">        This is similar to `tf.boolean_mask`.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Values to be checked whether they are inside of the limits. If not, the corresonding element (in the</span>
<span class="sd">                specified `axis`) is removed. The shape is expected to have the last dimension equal to n_obs.</span>
<span class="sd">            guarantee_limits: Guarantee that the values are already inside the rectangular limits.</span>
<span class="sd">            axis: The axis to remove the elements from. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Return an object with the same shape as `x` except that along `axis` elements have been</span>
<span class="sd">                removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="ow">and</span> <span class="n">guarantee_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered</span></div>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">):</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="o">=</span><span class="n">guarantee_limits</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">filtered</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of observables/axes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int &gt;= 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">n_obs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The observables (&quot;axes with str&quot;)the space is defined in.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">obs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The axes (&quot;obs with int&quot;) the space is defined in.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ZfitSpace</span><span class="p">]:</span>
        <span class="k">yield</span> <span class="bp">self</span>

<div class="viewcode-block" id="BaseSpace.get_reorder_indices"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.get_reorder_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_reorder_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Indices that would order the instances obs as `obs` respectively the instances axes as `axes`.</span>

<span class="sd">        Args:</span>
<span class="sd">            obs: Observables that the instances obs should be ordered to. Does not reorder, but just</span>
<span class="sd">                return the indices that could be used to reorder.</span>
<span class="sd">            axes: Axes that the instances obs should be ordered to. Does not reorder, but just</span>
<span class="sd">                return the indices that could be used to reorder.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New indices that would reorder the instances obs to be obs respectively axes.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CoordinatesUnderdefinedError: If neither `obs` nor `axes` is given</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get_reorder_indices</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span></div>

    <span class="c1"># TODO: remove, in coords</span>
    <span class="k">def</span> <span class="nf">_check_convert_input_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span><span class="p">,</span>
                                  <span class="n">allow_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeReturn</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_none</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AxesNotSpecifiedError</span><span class="p">(</span><span class="s2">&quot;TODO: Cannot be None&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">axes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">convert_to_container</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># TODO(Mayou36): extend like _check_obs?</span>

        <span class="k">return</span> <span class="n">axes</span>

    <span class="c1"># TODO: remove, in coords</span>
    <span class="k">def</span> <span class="nf">_check_convert_input_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span><span class="p">,</span>
                                 <span class="n">allow_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Input check: Convert `NOT_SPECIFIED` to None or check if obs are all strings.</span>

<span class="sd">        Args:</span>
<span class="sd">            obs:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_none</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ObsNotSpecifiedError</span><span class="p">(</span><span class="s2">&quot;TODO: Cannot be None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">obs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">convert_to_container</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
            <span class="n">obs_not_str</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obs</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">obs_not_str</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following observables are not strings: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_not_str</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obs</span>

    <span class="k">def</span> <span class="nf">_check_coords_allowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">to_check</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_check</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_check</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">self_coord</span> <span class="ow">in</span> <span class="n">to_check</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="n">self_coord</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">self_coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="o">!=</span> <span class="n">self_coord</span><span class="p">:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_superset</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">self_coord</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">CoordinatesIncompatibleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Superset is not allowed, but </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2"> is a superset&quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot; of </span><span class="si">{</span><span class="n">self_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_subset</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">self_coord</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">CoordinatesIncompatibleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subset is not allowed, but </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2"> is a subset&quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot; of </span><span class="si">{</span><span class="n">self_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_false</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rect_limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="s1">&#39;rectangular&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="s1">&#39;functional&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;zfit </span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2"> obs=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="si">}</span><span class="s2">, axes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="si">}</span><span class="s2">, limits=</span><span class="si">{</span><span class="n">limits</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot add a </span><span class="si">{}</span><span class="s2"> and a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">add_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># TODO: implement properly, just sketch</span>
<div class="viewcode-block" id="BaseSpace.get_sublimits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.get_sublimits">[docs]</a>    <span class="k">def</span> <span class="nf">get_sublimits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_limits</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">limits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="BaseSpace.add"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">SpaceOrSpacesTypeInput</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the limits of the spaces. Only works for the same obs.</span>

<span class="sd">        In case the observables are different, the order of the first space is taken.</span>

<span class="sd">        Args:</span>
<span class="sd">            other:</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~zfit.Space`:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># other = convert_to_container(other, container=list)</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="n">add_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="BaseSpace.combine"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.combine">[docs]</a>    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">SpaceOrSpacesTypeInput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZfitSpace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combine spaces with different obs (but consistent limits).</span>

<span class="sd">        Args:</span>
<span class="sd">            other:</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~zfit.Space`:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># other = convert_to_container(other, container=list)</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="n">combine_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">equal_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="BaseSpace.equal"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">allow_graph</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Compare the limits on equality. For ANY objects, this also returns true.</span>

<span class="sd">        If called inside a graph context *and* the limits are tensors, this will return a symbolic `tf.Tensor`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Result of the comparison</span>
<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">equal_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="n">allow_graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseSpace.__eq__"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compares two Limits for equality without graph mode allowed.</span>

<span class="sd">        Returns:</span>

<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseSpace.less_equal"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.less_equal">[docs]</a>    <span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set-like comparison for compatibility. If an object is less_equal to another, the limits are combatible.</span>

<span class="sd">        This can be used to determine whether a fitting range specification can handle another limit.</span>

<span class="sd">        If called inside a graph context *and* the limits are tensors, this will return a symbolic `tf.Tensor`.</span>


<span class="sd">        Args:</span>
<span class="sd">            other: Any other object to compare with</span>
<span class="sd">            allow_graph: If False and the function returns a symbolic tensor, raise IllegalInGraphModeError instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Result of the comparison</span>
<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">less_equal_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="n">allow_graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseSpace.__le__"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.__le__">[docs]</a>    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set-like comparison for compatibility. If an object is less_equal to another, the limits are combatible.</span>

<span class="sd">        This can be used to determine whether a fitting range specification can handle another limit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Result of the comparison</span>
<span class="sd">        Raises:</span>
<span class="sd">             IllegalInGraphModeError: it the comparison happens with tensors in a graph context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limits_frozen</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(((</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ldict</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ldict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">hash_val</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">limits_frozen</span><span class="p">,</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">hash_val</span>

<div class="viewcode-block" id="BaseSpace.reorder_x"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.BaseSpace.reorder_x">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x_obs</span><span class="p">,</span> <span class="n">x_axes</span><span class="p">,</span> <span class="n">func_obs</span><span class="p">,</span> <span class="n">func_axes</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">reorder_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_obs</span><span class="o">=</span><span class="n">x_obs</span><span class="p">,</span> <span class="n">x_axes</span><span class="o">=</span><span class="n">x_axes</span><span class="p">,</span>
                                     <span class="n">func_obs</span><span class="o">=</span><span class="n">func_obs</span><span class="p">,</span> <span class="n">func_axes</span><span class="o">=</span><span class="n">func_axes</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span></div>


<div class="viewcode-block" id="Space"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space">[docs]</a><span class="k">class</span> <span class="nc">Space</span><span class="p">(</span><span class="n">BaseSpace</span><span class="p">):</span>
    <span class="n">AUTO_FILL</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">ANY</span> <span class="o">=</span> <span class="n">ANY</span>
    <span class="n">ANY_LOWER</span> <span class="o">=</span> <span class="n">ANY_LOWER</span>  <span class="c1"># TODO: needed? or move everything inside?</span>
    <span class="n">ANY_UPPER</span> <span class="o">=</span> <span class="n">ANY_UPPER</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Space&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a space with the name (`obs`) of the axes (and it&#39;s number) and possibly it&#39;s limits.</span>

<span class="sd">        A space can be thought of as coordinates, possibly with the definition of a range (limits). For most use-cases,</span>
<span class="sd">        it is sufficient to specify a `Space` via observables; simple string identifiers. They can be multidimensional.</span>

<span class="sd">        Observables are like the columns of a spreadsheet/dataframe, and are therefore needed for any object that does</span>
<span class="sd">        numerical operations or holds data in order to match the right axes. On object creation, the observables are</span>
<span class="sd">        assigned using a `Space`. This is often used as the default space of an object and can be used as the</span>
<span class="sd">        default `norm_range`, sampling limits etc.</span>

<span class="sd">        Axes are the same concept as observables, but numbers, indexes, and are used *inside* an object. There,</span>
<span class="sd">        axes 0 corresponds to the 0th data column we get (which corresponds to a certain observable).</span>

<span class="sd">        Every space can have limits; they are either rectangular or an arbitrary function (together with rectangular</span>
<span class="sd">        limits). Spaces can be combined (multiplied) to create higher dimensional spaces.</span>
<span class="sd">        `Spaces` can be added, which combines them into one `Space` consisting of two disconnected limits.</span>

<span class="sd">        So integrating over the space consisting of the two added disconnected ranges,</span>
<span class="sd">        e.g. 0 to 1 and 2 to 3 will return the sum of the two separate integrals.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            lower_band = zfit.Space(&#39;obs1&#39;, (0, 1))</span>
<span class="sd">            upper_band = zfit.Space(&#39;obs1&#39;, (2, 3))</span>
<span class="sd">            combined_obs = lower_band + upper_band</span>
<span class="sd">            integral_comb = model.integrate(limits=combined_obs)</span>
<span class="sd">            # which is equivalent to the lower</span>
<span class="sd">            integral_sep = model.integrate(limits=lower_band) + model.integrate(limits=upper_band)</span>
<span class="sd">            assert integral_comb == integral_sep</span>


<span class="sd">        In principle, the same behavior could also be achieved by specifying an arbitrary function. Using the addition</span>
<span class="sd">        allows for certain optimizations inside.</span>



<span class="sd">        Args:</span>
<span class="sd">            obs:</span>
<span class="sd">            limits:</span>
<span class="sd">            name:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Space&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convert_input_limits</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limits</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span>
                                                       <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span> <span class="o">=</span> <span class="n">limits_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If there are limits and whether they are rectangular.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">limit</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_check_convert_input_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">LowerTypeInput</span><span class="p">,</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">UpperTypeInput</span><span class="p">],</span>
                                    <span class="n">rect_limits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">ztyping</span><span class="o">.</span><span class="n">LowerTypeReturn</span><span class="p">,</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">UpperTypeReturn</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Check and sanitize the input limits as well as the rectangular limits.</span>

<span class="sd">        Args:</span>
<span class="sd">            limit:</span>

<span class="sd">        Returns:</span>
<span class="sd">            Limits dictionary containing the observables and/or the axes as a key matching</span>
<span class="sd">                `ZfitLimits` objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limits_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">input_limits</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_limits</span><span class="p">,</span> <span class="n">Space</span><span class="p">):</span>
            <span class="n">space</span> <span class="o">=</span> <span class="n">input_limits</span>

            <span class="c1"># get the subset of obs/axes, then drop the other coord if not given</span>
            <span class="k">if</span> <span class="n">obs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">obs</span> <span class="ow">and</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">obs</span> <span class="ow">and</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">Coordinates</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
                <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">with_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">input_limits</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">get_limits</span><span class="p">()</span>

            <span class="n">obs</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">obs</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">axes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_limits</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># if not input_limits and rect_limits:</span>
            <span class="c1">#     input_limits = rect_limits</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">Limit</span><span class="p">(</span><span class="n">limit_fn</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">,</span> <span class="n">n_obs</span><span class="o">=</span><span class="n">n_obs</span><span class="p">)</span>
            <span class="n">i_old</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="n">limit</span><span class="o">.</span><span class="n">get_sublimits</span><span class="p">():</span>  <span class="c1"># split into smaller ones if possible</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i_old</span> <span class="o">+</span> <span class="n">lim</span><span class="o">.</span><span class="n">n_obs</span>
                <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">][</span><span class="n">obs</span><span class="p">[</span><span class="n">i_old</span><span class="p">:</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lim</span>
                <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">limits_dict</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">][</span><span class="n">axes</span><span class="p">[</span><span class="n">i_old</span><span class="p">:</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lim</span>
                <span class="n">i_old</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">input_limits</span> <span class="o">=</span> <span class="n">limits_dict</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_limits</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">input_limits</span> <span class="o">=</span> <span class="n">input_limits</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">input_limits</span> <span class="o">=</span> <span class="n">rect_limits</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">input_limits</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;obs&#39;</span> <span class="ow">in</span> <span class="n">input_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Probably internal error: wrong format of limits_dict&quot;</span><span class="p">)</span>

        <span class="c1"># check if obs is in the limits dict. If not, copy it from the axes</span>
        <span class="k">if</span> <span class="n">obs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;obs&#39;</span> <span class="ow">in</span> <span class="n">input_limits</span><span class="p">:</span>
                <span class="n">obs_limit_dict</span> <span class="o">=</span> <span class="n">input_limits</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obs_limit_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">axes_lim</span><span class="p">,</span> <span class="n">lim</span> <span class="ow">in</span> <span class="n">input_limits</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">obs_coords</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes_lim</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lim</span><span class="p">,</span> <span class="n">ZfitOrderableDimensional</span><span class="p">):</span>
                        <span class="n">lim</span> <span class="o">=</span> <span class="n">lim</span><span class="o">.</span><span class="n">with_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
                    <span class="n">obs_limit_dict</span><span class="p">[</span><span class="n">obs_coords</span><span class="p">]</span> <span class="o">=</span> <span class="n">lim</span>
            <span class="n">limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_limit_dict</span>

        <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">input_limits</span><span class="p">:</span>
                <span class="n">axes_limit_dict</span> <span class="o">=</span> <span class="n">input_limits</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axes_limit_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">obs_lim</span><span class="p">,</span> <span class="n">lim</span> <span class="ow">in</span> <span class="n">input_limits</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">axes_coords</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ob</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">obs_lim</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lim</span><span class="p">,</span> <span class="n">ZfitOrderableDimensional</span><span class="p">):</span>
                        <span class="n">lim</span> <span class="o">=</span> <span class="n">lim</span><span class="o">.</span><span class="n">with_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
                    <span class="n">axes_limit_dict</span><span class="p">[</span><span class="n">axes_coords</span><span class="p">]</span> <span class="o">=</span> <span class="n">lim</span>
            <span class="n">limits_dict</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">axes_limit_dict</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">axes</span> <span class="ow">and</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">limits_dict</span><span class="p">:</span>
            <span class="n">limits_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">obs</span> <span class="ow">and</span> <span class="s1">&#39;obs&#39;</span> <span class="ow">in</span> <span class="n">limits_dict</span><span class="p">:</span>
            <span class="n">limits_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">)</span>

        <span class="c1"># TODO: extend input processing?</span>
        <span class="k">return</span> <span class="n">limits_dict</span>

<div class="viewcode-block" id="Space.get_limits"><a class="viewcode-back" href="../../../full_api/zfit.dimension.html#zfit.Space.get_limits">[docs]</a>    <span class="k">def</span> <span class="nf">get_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsDictWithCoords</span><span class="p">,</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsDictNoCoords</span><span class="p">]:</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">both_none_or_true</span> <span class="o">=</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">both_none_or_true</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ObsIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Obs are not defined for this instance, no limits set for obs.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">both_none_or_true</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">AxesIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Axes are not defined for this instance, no limits set for axes.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obs</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_limits_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_limits_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_dict</span></div>

    <span class="nd">@property</span>
    <span class="c1"># @deprecated(date=None, instructions=&quot;`limits` is depreceated (currently) due to the unambiguous nature of the word.&quot;</span>
    <span class="c1">#                                     &quot; Use `inside` to check if an Tensor is inside the limits or&quot;</span>
    <span class="c1">#                                     &quot; `rect_limits` if you need to retreave the rectangular limits.&quot;)</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the limits.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the rectangular limits as `np.ndarray``tf.Tensor` if they are set and not false.</span>

<span class="sd">            The rectangular limits can be used for sampling. They do not in general represent the limits</span>
<span class="sd">            of the object as a functional limit can be set and to check if something is inside the limits,</span>
<span class="sd">            the method :py:meth:`~Limit.inside` should be used.</span>

<span class="sd">            In order to test if the limits are False or None, it is recommended to use the appropriate methods</span>
<span class="sd">            `limits_are_false` and `limits_are_set`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lower and upper limits.</span>
<span class="sd">        Raises:</span>
<span class="sd">            LimitsNotSpecifiedError: If there are not limits set or they are False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limits are False or not set, cannot return the rectangular limits.&quot;</span><span class="p">)</span>
        <span class="n">lower_ordered</span><span class="p">,</span> <span class="n">upper_ordered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits_z</span><span class="p">()</span>
        <span class="n">rect_limits</span> <span class="o">=</span> <span class="n">lower_ordered</span><span class="p">,</span> <span class="n">upper_ordered</span>
        <span class="k">return</span> <span class="n">rect_limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_rect_limits_tf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the limits as `tf.Tensor`.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limits are False or not set, cannot return the rectangular limits.&quot;</span><span class="p">)</span>
        <span class="n">lower_ordered</span><span class="p">,</span> <span class="n">upper_ordered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits_z</span><span class="p">()</span>
        <span class="n">rect_limits</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">lower_ordered</span><span class="p">),</span> <span class="n">z</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">upper_ordered</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rect_limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits_np</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsNPReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the rectangular limits as `np.ndarray`. Raise error if not possible.</span>

<span class="sd">        Rectangular limits are returned as numpy arrays which can be useful when doing checks that do not</span>
<span class="sd">        need to be involved in the computation later on as they allow direct interaction with Python as</span>
<span class="sd">        compared to `tf.Tensor` inside a graph function.</span>

<span class="sd">        In order to test if the limits are False or None, it is recommended to use the appropriate methods</span>
<span class="sd">        `limits_are_false` and `limits_are_set`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of two `np.ndarray` with shape (1, n_obs) typically. The last</span>
<span class="sd">                dimension is always `n_obs`, the first can be vectorized. This allows unstacking</span>
<span class="sd">                with `z.unstack_x()` as can be done with data.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CannotConvertToNumpyError: In case the conversion fails.</span>
<span class="sd">            LimitsNotSpecifiedError: If the limits are not set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits_z</span><span class="p">()</span>

        <span class="n">lower</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">_try_convert_numpy</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">_try_convert_numpy</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">RectLowerReturnType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The lower, rectangular limits, equivalent to `rect_limits[0]` with shape (..., n_obs)</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lower, rectangular limits as `np.ndarray` or `tf.Tensor`</span>
<span class="sd">        Raises:</span>
<span class="sd">            LimitsNotSpecifiedError: If the limits are not set or are false</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">UpperTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The upper, rectangular limits, equivalent to `rect_limits[1]` with shape (..., n_obs)</span>

<span class="sd">        Returns:</span>
<span class="sd">            The upper, rectangular limits as `np.ndarray` or `tf.Tensor`</span>
<span class="sd">        Raises:</span>
<span class="sd">            LimitsNotSpecifiedError: If the limits are not set or are false</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_rect_limits_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">limits_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rect_lower_unordered</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rect_upper_unordered</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obs_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">coord_limit</span><span class="p">,</span> <span class="n">limit</span> <span class="ow">in</span> <span class="n">limits_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># TODO: maybe refactor with extract limits?</span>
            <span class="n">limits_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">coord_limit</span><span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">rect_limits</span>  <span class="c1"># to get the numpy or tensor</span>
            <span class="n">rect_lower_unordered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
            <span class="n">rect_upper_unordered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="n">reorder_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x_obs&#39;</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="s1">&#39;x_axes&#39;</span><span class="p">:</span> <span class="n">limits_coords</span><span class="p">}</span>

        <span class="c1"># stack the limits and reorder them according to the own coords</span>
        <span class="n">lower_stacked</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rect_lower_unordered</span><span class="p">,</span>
                                          <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lower_ordered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_x</span><span class="p">(</span><span class="n">lower_stacked</span><span class="p">,</span> <span class="o">**</span><span class="n">reorder_kwargs</span><span class="p">)</span>
        <span class="n">upper_stacked</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rect_upper_unordered</span><span class="p">,</span>
                                          <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">upper_ordered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_x</span><span class="p">(</span><span class="n">upper_stacked</span><span class="p">,</span> <span class="o">**</span><span class="n">reorder_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower_ordered</span><span class="p">,</span> <span class="n">upper_ordered</span>

<div class="viewcode-block" id="Space.rect_area"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.rect_area">[docs]</a>    <span class="k">def</span> <span class="nf">rect_area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the total rectangular area of all the limits and axes. Useful, for example, for MC integration.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calculate_rect_area</span><span class="p">(</span><span class="n">rect_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rect_limits_tf</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits_are_tensors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True if the rectangular limits are tensors.</span>

<span class="sd">        If a limit with tensors is evaluated inside a graph context, comparison operations will fail.</span>

<span class="sd">        Returns:</span>
<span class="sd">            If the rectangular limits are tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits_np</span>
        <span class="k">except</span> <span class="n">CannotConvertToNumpyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If there are limits and whether they are rectangular.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">limits_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">rect_limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">limit</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="n">limits_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">all_rect_limits</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_rect_limits</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rect_limits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits_are_false</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If the limits have been set to False, so the object on purpose does not contain limits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if limits is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">limit</span><span class="o">.</span><span class="n">limits_are_false</span>
                   <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether there are limits set and they are not false.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_set</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_false</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits_are_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">limit</span><span class="o">.</span><span class="n">limits_are_set</span>
                   <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of events, the dimension of the first shape.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of events, the dimension of the first shape. If this is &gt; 1 or None,</span>
<span class="sd">                it&#39;s vectorized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_lower</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="s2">&quot;Depreceated, use .rect_limits or .inside to check if a value is inside or use&quot;</span>
                                        <span class="s2">&quot;rect_limits to receive the rectangular limits.&quot;</span><span class="p">)</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">limit2d</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Simplified `limits` for exactly 2 obs, 1 limit: return the tuple(low_obs1, low_obs2, up_obs1, up_obs2).</span>

<span class="sd">        Returns:</span>
<span class="sd">            So `low_x, low_y, up_x, up_y = space.limit2d` for a single, 2 obs limit.</span>
<span class="sd">                low_x is the lower limit in x, up_x is the upper limit in x etc.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: if the conditions (n_obs or n_limits) are not satisfied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Nobs is not two.&quot;</span><span class="p">)</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span>
        <span class="k">return</span> <span class="n">lower</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lower</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">upper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">upper</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># raise BreakingAPIChangeError(&quot;This function is gone, use .rect_limits or .inside instead&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits1d</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Simplified `.limits` for exactly 1 obs, n limits: return the tuple(low_1, ..., low_n, up_1, ..., up_n).</span>

<span class="sd">        Returns:</span>
<span class="sd">            So `low_1, low_2, up_1, up_2 = space.limits1d` for several, 1 obs limits.</span>
<span class="sd">                low_1 to up_1 is the first interval, low_2 to up_2 is the second interval etc.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: if the conditions (n_obs or n_limits) are not satisfied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span><span class="p">(</span><span class="s2">&quot;This function is gone. Instead iterate through the space and get each limit out.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="c1"># @deprecated(date=None, instructions=&quot;Depreceated (currently) due to the unambiguous nature of the word.&quot;</span>
    <span class="c1">#                                     &quot; Use `rect_lower` instead.&quot;)</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LowerTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the lower limits.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_lower</span>
        <span class="c1"># raise BreakingAPIChangeError(&quot;Use rect_lower&quot;)</span>

    <span class="nd">@property</span>
    <span class="c1"># @deprecated(date=None, instructions=&quot;depreceated (currently) due to the unambiguous nature of the word.&quot;</span>
    <span class="c1">#                                     &quot; Use `rect_upper` instead.&quot;)</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">UpperTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the upper limits.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_upper</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of different limits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int &gt;= 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="s2">&quot;Iterate over the space directly and&quot;</span>
                                        <span class="s2">&quot; use the limits from the spaces.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iter_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_tuple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">_IterLimitsTypeReturn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;REMOVED.Return the limits, either as :py:class:`~zfit.Space` objects or as pure limits-tuple.</span>

<span class="sd">        This makes iterating over limits easier: `for limit in space.iter_limits()`</span>
<span class="sd">        allows to, for example, pass `limit` to a function that can deal with simple limits</span>
<span class="sd">        only or if `as_tuple` is True the `limit` can be directly used to calculate something.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. code:: python</span>

<span class="sd">                for lower, upper in space.iter_limits(as_tuple=True):</span>
<span class="sd">                    integrals = integrate(lower, upper)  # calculate integral</span>
<span class="sd">                integral = sum(integrals)</span>


<span class="sd">        Returns:</span>
<span class="sd">            List[:py:class:`~zfit.Space`] or List[limit,...]:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span>

<div class="viewcode-block" id="Space.with_limits"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.with_limits">[docs]</a>    <span class="k">def</span> <span class="nf">with_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">limits</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">rect_limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsInputType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZfitSpace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the space with the new `limits` (and the new `name`).</span>

<span class="sd">        Args:</span>
<span class="sd">            limits: Limits to use. Can be rectangular, a function (requires to also specify `rect_limits`</span>
<span class="sd">                or an instance of ZfitLimit.</span>
<span class="sd">            rect_limits: Rectangular limits that will be assigned with the instance</span>
<span class="sd">            name: Human readable name</span>

<span class="sd">        Returns:</span>
<span class="sd">            Copy of the current object with the new limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">,</span>
                               <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="Space.reorder_x"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.reorder_x">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                  <span class="o">*</span><span class="p">,</span>
                  <span class="n">x_obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">x_axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">func_obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">func_axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">XTypeReturnNoData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reorder x in the last dimension either according to its own obs or assuming a function ordered with func_obs.</span>

<span class="sd">        There are two obs or axes around: the one associated with this Coordinate object and the one associated with x.</span>
<span class="sd">        If x_obs or x_axes is given, then this is assumed to be the obs resp. the axes of x and x will be reordered</span>
<span class="sd">        according to `self.obs` resp. `self.axes`.</span>

<span class="sd">        If func_obs resp. func_axes is given, then x is assumed to have `self.obs` resp. `self.axes` and will be</span>
<span class="sd">        reordered to align with a function ordered with `func_obs` resp. `func_axes`.</span>

<span class="sd">        Switching `func_obs` for `x_obs` resp. `func_axes` for `x_axes` inverts the reordering of x.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Tensor to be reordered, last dimension should be n_obs resp. n_axes</span>
<span class="sd">            x_obs: Observables associated with x. If both, x_obs and x_axes are given, this has precedency over the</span>
<span class="sd">                latter.</span>
<span class="sd">            x_axes: Axes associated with x.</span>
<span class="sd">            func_obs: Observables associated with a function that x will be given to. Reorders x accordingly and assumes</span>
<span class="sd">                self.obs to be the obs of x. If both, `func_obs` and `func_axes` are given, this has precedency over the</span>
<span class="sd">                latter.</span>
<span class="sd">            func_axes: Axe associated with a function that x will be given to. Reorders x accordingly and assumes</span>
<span class="sd">                self.axes to be the axes of x.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The reordered array-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">reorder_x</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">x_obs</span><span class="o">=</span><span class="n">x_obs</span><span class="p">,</span> <span class="n">x_axes</span><span class="o">=</span><span class="n">x_axes</span><span class="p">,</span> <span class="n">func_obs</span><span class="o">=</span><span class="n">func_obs</span><span class="p">,</span> <span class="n">func_axes</span><span class="o">=</span><span class="n">func_axes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Space.with_obs"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.with_obs">[docs]</a>    <span class="k">def</span> <span class="nf">with_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span><span class="p">],</span>
                 <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZfitSpace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new Space that has `obs`; sorted by or set or dropped.</span>

<span class="sd">        The behavior is as follows:</span>

<span class="sd">         * obs are already set:</span>

<span class="sd">           * input obs are None: the observables will be dropped. If no axes are set, an error</span>
<span class="sd">             will be raised, as no coordinates will be assigned to this instance anymore.</span>
<span class="sd">           * input obs are not None: the instance will be sorted by the incoming obs. If axes or other</span>
<span class="sd">             objects have an associated order (e.g. data, limits,...), they will be reordered as well.</span>
<span class="sd">             If a strict subset is given (and allow_subset is True), only a subset will be returned.</span>
<span class="sd">             This can be used to take a subspace of limits, data etc.</span>
<span class="sd">             If a strict superset is given (and allow_superset is True), the obs will be sorted accordingly as</span>
<span class="sd">             if the obs not contained in the instances obs were not in the input obs.</span>
<span class="sd">         * obs are not set:</span>

<span class="sd">           * if the input obs are None, the same object is returned.</span>
<span class="sd">           * if the input obs are not None, they will be set as-is and now correspond to the already</span>
<span class="sd">             existing axes in the object.</span>

<span class="sd">        Args:</span>
<span class="sd">            obs: Observables to sort/associate this instance with</span>
<span class="sd">            allow_superset: if False and a strict superset of the own observables is given, an error</span>
<span class="sd">            is raised.</span>
<span class="sd">            allow_subset:if False and a strict subset of the own observables is given, an error</span>
<span class="sd">            is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the object with the new ordering/observables</span>

<span class="sd">        Raises:</span>
<span class="sd">            CoordinatesUnderdefinedError: if obs is None and the instance does not have axes</span>
<span class="sd">            ObsIncompatibleError: if `obs` is a superset and allow_superset is False or a subset and</span>
<span class="sd">                allow_allow_subset is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># drop obs, check if there are axes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AxesIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Cannot remove obs (using None) for a Space without axes&quot;</span><span class="p">)</span>
            <span class="n">new_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">new_limits</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">_convert_obs_to_str</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">coords</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="Space.with_axes"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.with_axes">[docs]</a>    <span class="k">def</span> <span class="nf">with_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span><span class="p">],</span>
                  <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZfitSpace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance that has `axes`; sorted by or set or dropped.</span>

<span class="sd">        The behavior is as follows:</span>

<span class="sd">         * axes are already set:</span>

<span class="sd">           * input axes are None: the axes will be dropped. If no observables are set, an error</span>
<span class="sd">             will be raised, as no coordinates will be assigned to this instance anymore.</span>
<span class="sd">           * input axes are not None: the instance will be sorted by the incoming axes. If obs or other</span>
<span class="sd">             objects have an associated order (e.g. data, limits,...), they will be reordered as well.</span>
<span class="sd">             If a strict subset is given (and allow_subset is True), only a subset will be returned. This can</span>
<span class="sd">             be used to retrieve a subspace of limits, data etc.</span>
<span class="sd">             If a strict superset is given (and allow_superset is True), the axes will be sorted accordingly as</span>
<span class="sd">             if the axes not contained in the instances axes were not present in the input axes.</span>
<span class="sd">         * axes are not set:</span>

<span class="sd">           * if the input axes are None, the same object is returned.</span>
<span class="sd">           * if the input axes are not None, they will be set as-is and now correspond to the already</span>
<span class="sd">             existing obs in the object.</span>

<span class="sd">        Args:</span>
<span class="sd">            axes: Axes to sort/associate this instance with</span>
<span class="sd">            allow_superset: if False and a strict superset of the own axeservables is given, an error</span>
<span class="sd">            is raised.</span>
<span class="sd">            allow_subset:if False and a strict subset of the own axeservables is given, an error</span>
<span class="sd">            is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the object with the new ordering/axes</span>
<span class="sd">        Raises:</span>
<span class="sd">            CoordinatesUnderdefinedError: if obs is None and the instance does not have axes</span>
<span class="sd">            AxesIncompatibleError: if `axes` is a superset and allow_superset is False or a subset and</span>
<span class="sd">                allow_allow_subset is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># drop axes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ObsIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Cannot remove axes (using None) for a Space without obs&quot;</span><span class="p">)</span>
            <span class="n">new_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">new_limits</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">convert_to_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">AxesIncompatibleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying to set axes </span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2"> to object with obs </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">new_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
                <span class="n">new_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">coords</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="Space.with_coords"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.with_coords">[docs]</a>    <span class="k">def</span> <span class="nf">with_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">coords</span><span class="p">:</span> <span class="n">ZfitOrderableDimensional</span><span class="p">,</span>
                    <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Space&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new :py:class:`~zfit.Space` with reordered observables and/or axes.</span>

<span class="sd">        The behavior is that _at least one coordinate (obs or axes) has to be set in both instances</span>
<span class="sd">        (the space itself or in `coords`). If both match, observables is taken as the defining coordinate.</span>
<span class="sd">        The space is sorted according to the defining coordinate and the other coordinate is sorted as well.</span>
<span class="sd">        If either the space did not have the &quot;weaker coordinate&quot; (e.g. both have observables, but only coords</span>
<span class="sd">        has axes), then the resulting Space will have both.</span>
<span class="sd">        If both have both coordinates, obs and axes, and sorting for obs results in non-matchin axes results</span>
<span class="sd">        in axes being dropped.</span>

<span class="sd">        Args:</span>
<span class="sd">            coords: An instance of :py:class:`Coordinates`</span>
<span class="sd">            allow_superset: If `False` and a strict superset is given, an error is raised</span>
<span class="sd">            allow_subset: If `False` and a strict subset is given, an error is raised</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~zfit.Space`:</span>
<span class="sd">        Raises:</span>
<span class="sd">            CoordinatesUnderdefinedError: if neither both obs or axes are specified.</span>
<span class="sd">            CoordinatesIncompatibleError: if `coords` is a superset and allow_superset is False or a subset and</span>
<span class="sd">                allow_allow_subset is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coords</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_space_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use this axes: first drop the other one</span>
                <span class="k">if</span> <span class="n">new_space_obs</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_space_obs</span> <span class="o">=</span> <span class="n">new_space_obs</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="c1"># filter in case there are super/subsets</span>
                <span class="n">coords_axes</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">new_space_obs</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span>
                                              <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
                <span class="n">new_space_obs</span> <span class="o">=</span> <span class="n">new_space_obs</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">coords_axes</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>  <span class="c1"># are the same or self.axes is None</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="n">new_space_obs</span>


        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coords</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_space_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># filter in case there are super/subsets</span>
                <span class="n">coords_obs</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">new_space_axes</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span>
                                              <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
                <span class="n">new_space_axes</span> <span class="o">=</span> <span class="n">new_space_axes</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">coords_obs</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="n">new_space_axes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CoordinatesUnderdefinedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Neither the axes nor the obs are specified in both objects&quot;</span>
                                               <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="Space.with_autofill_axes"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.with_autofill_axes">[docs]</a>    <span class="k">def</span> <span class="nf">with_autofill_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;zfit.Space&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Overwrite the axes of the current object with axes corresponding to range(len(n_obs)).</span>

<span class="sd">        This effectively fills with (0, 1, 2,...) and can be used mostly when an object enters a PDF or</span>
<span class="sd">        similar. `overwrite` allows to remove the axis first in case there are already some set.</span>

<span class="sd">        .. code-block::</span>

<span class="sd">            object.obs -&gt; (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>
<span class="sd">            object.axes -&gt; None</span>

<span class="sd">            object.with_autofill_axes()</span>

<span class="sd">            object.obs -&gt; (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>
<span class="sd">            object.axes -&gt; (0, 1, 2)</span>


<span class="sd">        Args:</span>
<span class="sd">            overwrite: If axes are already set, replace the axes with the autofilled ones.</span>
<span class="sd">                If axes is already set and `overwrite` is False, raise an error.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The object with the new axes</span>

<span class="sd">        Raises:</span>
<span class="sd">            AxesIncompatibleError: if the axes are already set and `overwrite` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_autofill_axes</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="c1"># new_space = self.with_coords(new_coords)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">new_coords</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_space</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="Space.get_subspace"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.get_subspace">[docs]</a>    <span class="k">def</span> <span class="nf">get_subspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Space&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a :py:class:`~zfit.Space` consisting of only a subset of the `obs`/`axes` (only one allowed).</span>

<span class="sd">        Args:</span>
<span class="sd">            obs: Observables of the subspace to return.</span>
<span class="sd">            axes: Axes of the subspace to return.</span>
<span class="sd">            name: Human readable names</span>

<span class="sd">        Returns:</span>
<span class="sd">            A space containing only a subspace (and sublimits etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify `obs` *and* `axes` to get subspace.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either `obs` or `axes` has to be specified and not None&quot;</span><span class="p">)</span>

        <span class="c1"># try to use observables to get index</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convert_input_obs</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convert_input_axes</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_limits</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>
            <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_limits</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">obs</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">limits_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="Space.with_obs_axes"><a class="viewcode-back" href="../../../full_api/zfit.dimension.html#zfit.Space.with_obs_axes">[docs]</a>    <span class="k">def</span> <span class="nf">with_obs_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span><span class="p">(</span><span class="s2">&quot;What is this needed for?&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Space.get_obs_axes"><a class="viewcode-back" href="../../../full_api/zfit.dimension.html#zfit.Space.get_obs_axes">[docs]</a>    <span class="k">def</span> <span class="nf">get_obs_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span><span class="p">(</span><span class="s2">&quot;Simply get the coords if needed&quot;</span><span class="p">)</span></div>

    <span class="c1"># @deprecated(date=None, instructions=&quot;Use rect_area to obtain the rectangular area.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obs_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span>

<div class="viewcode-block" id="Space.area"><a class="viewcode-back" href="../../../full_api/zfit.dimension.html#zfit.Space.area">[docs]</a>    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the total area of all the limits and axes. Useful, for example, for MC integration.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_area</span><span class="p">()</span></div>

<div class="viewcode-block" id="Space.copy"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">overwrite_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;zfit.Space&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new :py:class:`~zfit.Space` using the current attributes and overwriting with</span>
<span class="sd">        `overwrite_overwrite_kwargs`.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The new name. If not given, the new instance will be named the same as the</span>
<span class="sd">                current one.</span>
<span class="sd">            **overwrite_kwargs:</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~zfit.Space`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                  <span class="s1">&#39;limits&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">,</span>
                  <span class="s1">&#39;axes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
                  <span class="s1">&#39;obs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">}</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overwrite_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">overwrite_kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Not usable keys in `overwrite_kwargs`: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">overwrite_kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)))</span>

        <span class="n">new_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

    <span class="c1"># Operators</span>

    <span class="k">def</span> <span class="nf">_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">):</span>
        <span class="n">xs_inside</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obs_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">limits_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">coords</span><span class="p">,</span> <span class="n">limit</span> <span class="ow">in</span> <span class="n">limits_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">reorder_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;func_obs&#39;</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="s1">&#39;func_axes&#39;</span><span class="p">:</span> <span class="n">coords</span><span class="p">}</span>
            <span class="n">x_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">reorder_kwargs</span><span class="p">)</span>
            <span class="n">x_inside</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x_sub</span><span class="p">)</span>
            <span class="n">xs_inside</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_inside</span><span class="p">)</span>
        <span class="n">all_inside</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">xs_inside</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_inside</span>

    <span class="nd">@property</span>  <span class="c1"># TODO(discussion): depreceate 1d limits? or keep?</span>
    <span class="c1"># @deprecated(date=None, instructions=&quot;depreceated, use `rect_limits` instead which has a similar functionality&quot;</span>
    <span class="c1">#                                     &quot; Use `inside` to check if an Tensor is inside the limits.&quot;)</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">limit1d</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Simplified limits getter for 1 obs, 1 limit only: return the tuple(lower, upper).</span>

<span class="sd">        Returns:</span>
<span class="sd">            So :code:`lower, upper = space.limit1d` for a simple, 1 obs limit.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: if the conditions (n_obs or n_limits) are not satisfied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot call `limit1d, as `Space` has more than one observables: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_limits</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot call `limit1d, as `Space` has several limits: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_limits</span><span class="p">))</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_limits</span>
        <span class="k">return</span> <span class="n">lower</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Space.from_axes"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.Space.html#zfit.Space.from_axes">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="s2">&quot;Use directly the class to create a Space. E.g. zfit.Space(axes=(0, 1), ...)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_axes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span><span class="p">,</span>
                  <span class="n">limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">rect_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;zfit.Space&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a space from `axes` instead of from `obs`.</span>

<span class="sd">        Args:</span>
<span class="sd">            rect_limits:</span>
<span class="sd">            axes:</span>
<span class="sd">            limits:</span>
<span class="sd">            name:</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~zfit.Space`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO(v0.5):</span>
        <span class="c1"># raise BreakingAPIChangeError(&quot;from_axes is not needed anymore, create a Space directly.&quot;)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">convert_to_container</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AxesNotSpecifiedError</span><span class="p">(</span><span class="s2">&quot;Axes cannot be `None`&quot;</span><span class="p">)</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div></div>


<div class="viewcode-block" id="extract_limits_from_dict"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.extract_limits_from_dict">[docs]</a><span class="k">def</span> <span class="nf">extract_limits_from_dict</span><span class="p">(</span><span class="n">limits_dict</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need to specify at least one, obs or axes.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># obs has precedency</span>
    <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obs_in_use</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">coords_to_extract</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obs_in_use</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">coords_to_extract</span> <span class="o">=</span> <span class="n">obs</span>
    <span class="n">coords_to_extract</span> <span class="o">=</span> <span class="n">convert_to_container</span><span class="p">(</span><span class="n">coords_to_extract</span><span class="p">)</span>
    <span class="n">coords_to_extract</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coords_to_extract</span><span class="p">)</span>

    <span class="n">limits_to_eval</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">limit_dict</span> <span class="o">=</span> <span class="n">limits_dict</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="n">keys_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">limit_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key_coords</span><span class="p">,</span> <span class="n">limit</span> <span class="ow">in</span> <span class="n">keys_sorted</span><span class="p">:</span>
        <span class="n">coord_intersec</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">key_coords</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">coords_to_extract</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coord_intersec</span><span class="p">:</span>  <span class="c1"># this limit does not contain any requested obs</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">coord_intersec</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">key_coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">ZfitOrderableDimensional</span><span class="p">):</span>  <span class="c1"># drop coordinates if given</span>
                <span class="k">if</span> <span class="n">obs_in_use</span><span class="p">:</span>
                    <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">limits_to_eval</span><span class="p">[</span><span class="n">key_coords</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord_limit</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">key_coords</span> <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coord_intersec</span><span class="p">]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">:</span> <span class="n">coord_limit</span><span class="p">}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sublimit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">get_subspace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">InvalidLimitSubspaceError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidLimitSubspaceError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot extract </span><span class="si">{</span><span class="n">coord_intersec</span><span class="si">}</span><span class="s2"> from limit </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">sublimit_coord</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">obs</span> <span class="k">if</span> <span class="n">obs_in_use</span> <span class="k">else</span> <span class="n">limit</span><span class="o">.</span><span class="n">axes</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sublimit</span><span class="p">,</span> <span class="n">ZfitOrderableDimensional</span><span class="p">):</span>  <span class="c1"># drop coordinates if given</span>
                <span class="k">if</span> <span class="n">obs_in_use</span><span class="p">:</span>
                    <span class="n">sublimit</span> <span class="o">=</span> <span class="n">sublimit</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sublimit</span> <span class="o">=</span> <span class="n">sublimit</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">limits_to_eval</span><span class="p">[</span><span class="n">sublimit_coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublimit</span>
            <span class="n">coords_to_extract</span> <span class="o">-=</span> <span class="n">coord_intersec</span>
    <span class="k">return</span> <span class="n">limits_to_eval</span></div>


<div class="viewcode-block" id="add_spaces"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.add_spaces.html#zfit.add_spaces">[docs]</a><span class="k">def</span> <span class="nf">add_spaces</span><span class="p">(</span><span class="o">*</span><span class="n">spaces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;ZfitSpace&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add two spaces and merge their limits if possible or return False.</span>

<span class="sd">    Args:</span>
<span class="sd">        spaces:</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[None, :py:class:`~zfit.Space`, bool]:</span>

<span class="sd">    Raises:</span>
<span class="sd">        LimitsIncompatibleError: if limits of the `spaces` cannot be merged because they overlap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># spaces = convert_to_container(spaces)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can only add type ZfitSpace, not </span><span class="si">{</span><span class="n">spaces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MultiSpace</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_coord"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.get_coord">[docs]</a><span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">obs_in_use</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">obs_in_use</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">obs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">axes</span></div>


<div class="viewcode-block" id="combine_spaces"><a class="viewcode-back" href="../../../user_api/dimension/zfit.dimension.combine_spaces.html#zfit.combine_spaces">[docs]</a><span class="k">def</span> <span class="nf">combine_spaces</span><span class="p">(</span><span class="o">*</span><span class="n">spaces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Space</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Combine spaces with different `obs` and `limits` to one `space`.</span>

<span class="sd">    Checks if the limits in each obs coincide *exactly*. If this is not the case, the combination</span>
<span class="sd">    is not unambiguous and `False` is returned</span>

<span class="sd">    Args:</span>
<span class="sd">        spaces:</span>

<span class="sd">    Returns:</span>
<span class="sd">        Returns False if the limits don&#39;t coincide in one or more obs. Otherwise</span>
<span class="sd">            return the :py:class:`~zfit.Space` with all obs from `spaces` sorted by the order of `spaces` and with the</span>
<span class="sd">            combined limits.</span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if only one space is given</span>
<span class="sd">        LimitsIncompatibleError: If the limits of one or more spaces (or within a space) overlap</span>
<span class="sd">        LimitsNotSpecifiedError: If the limits for one or more obs but not all are None or False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">convert_to_container</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
    <span class="c1"># if len(spaces) &lt;= 1:</span>
    <span class="c1">#     return spaces</span>
    <span class="c1"># raise ValueError(&quot;Need at least two spaces to test limit consistency.&quot;)  # TODO: allow? usecase?</span>

    <span class="n">common_obs_ordered</span> <span class="o">=</span> <span class="n">common_obs</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">)</span>
    <span class="n">common_axes_ordered</span> <span class="o">=</span> <span class="n">common_axes</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">)</span>
    <span class="n">using_obs</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">common_obs_ordered</span><span class="p">)</span>
    <span class="n">common_coords_ordered</span> <span class="o">=</span> <span class="n">common_obs_ordered</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="n">common_axes_ordered</span>

    <span class="c1"># sort the spaces</span>
    <span class="k">if</span> <span class="n">using_obs</span><span class="p">:</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">common_obs_ordered</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)</span>
        <span class="n">all_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">common_axes_ordered</span><span class="p">:</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">common_axes_ordered</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)</span>
        <span class="n">all_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">axes</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CoordinatesUnderdefinedError</span><span class="p">(</span><span class="s2">&quot;Neither `obs` nor `axes` exist in all spaces.&quot;</span><span class="p">)</span>

    <span class="n">all_limits_false</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">limits_are_false</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">])</span>
    <span class="n">all_limits_not_set</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">space</span><span class="o">.</span><span class="n">limits_are_set</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">])</span>
    <span class="n">has_limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">has_limits</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">all_limits_false</span><span class="p">:</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">all_limits_not_set</span><span class="p">:</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">has_limits</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">LimitsNotSpecifiedError</span><span class="p">(</span><span class="s2">&quot;Limits either have to be set, not set, or False for all spaces to be combined.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">space_combinations</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">spaces</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">space_combinations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># there are MultiSpaces in there</span>
            <span class="n">all_combinations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">spa</span> <span class="ow">in</span> <span class="n">space_combinations</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="n">LimitsIncompatibleError</span><span class="p">):</span>
                    <span class="n">all_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combine_spaces</span><span class="p">(</span><span class="o">*</span><span class="n">spa</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">all_combinations</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">LimitsIncompatibleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The limits of </span><span class="si">{</span><span class="n">spaces</span><span class="si">}</span><span class="s2"> are all not compatible to be combined.&quot;</span><span class="p">)</span>
            <span class="c1"># filter, as can be False: non-overlapping limits e.g. if we have two MultiSpace</span>
            <span class="n">filtered_combinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">all_combinations</span> <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">MultiSpace</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">all_combinations</span><span class="p">,</span>
                              <span class="n">obs</span><span class="o">=</span><span class="n">common_obs_ordered</span> <span class="k">if</span> <span class="n">common_obs_ordered</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">axes</span><span class="o">=</span><span class="n">common_axes_ordered</span> <span class="k">if</span> <span class="n">common_axes_ordered</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># TODO: spaces that have multidim limits?</span>
        <span class="n">limits_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">non_unique_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">unique_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">common_coords_ordered</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">all_coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">non_unique_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">common_coords_ordered</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">unique_coords</span><span class="p">:</span>
                <span class="n">space</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span> <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">using_obs</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">get_subspace</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">unique_coords</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                           <span class="n">axes</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="n">unique_coords</span><span class="p">)</span>
                <span class="n">limits_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">get_limits</span><span class="p">()[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">using_obs</span><span class="p">):</span>
                    <span class="n">unique_coords</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">non_unique_coords</span><span class="p">:</span>
                <span class="n">non_unique_spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span> <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">using_obs</span><span class="p">)]</span>
                <span class="n">common_coords_non_unique</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">get_coord</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">using_obs</span><span class="p">))</span>
                                                                   <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">non_unique_spaces</span><span class="p">]))</span>
                <span class="c1"># do the below to check if we can take the subspace</span>
                <span class="n">non_unique_subspaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">get_subspace</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">common_coords_non_unique</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">axes</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="n">common_coords_non_unique</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">non_unique_spaces</span><span class="p">]</span>

                <span class="c1"># TODO compare limits</span>
                <span class="n">any_non_equal</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">non_unique_subspaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">non_unique_subspaces</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="k">if</span> <span class="n">any_non_equal</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">LimitsIncompatibleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limits in coord </span><span class="si">{</span><span class="n">common_coords_non_unique</span><span class="si">}</span><span class="s2"> do not match for spaces&quot;</span>
                                                  <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">non_unique_subspaces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">non_unique_subspace</span> <span class="o">=</span> <span class="n">non_unique_subspaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">limits_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">non_unique_subspace</span><span class="o">.</span><span class="n">get_limits</span><span class="p">()[</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">non_unique_subspace</span><span class="p">,</span> <span class="n">using_obs</span><span class="p">):</span>
                    <span class="n">non_unique_coords</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># fine, since it is already satisfied by a space</span>
        <span class="c1">#</span>
        <span class="c1"># for coord in common_coords_ordered:</span>
        <span class="c1">#     space_with_coord = [space for space in spaces if coord in get_coord(space, using_obs)]</span>
        <span class="c1">#     assert not any(isinstance(space, MultiSpace) for space in space_with_coord), &quot;bug, should be caught before.&quot;</span>
        <span class="c1">#     assert space_with_coord, &quot;empty, cannot be. This is a bug.&quot;</span>
        <span class="c1">#     limits_coord = []</span>
        <span class="c1">#     for space in space_with_coord:</span>
        <span class="c1">#         if type(space) == Space:  # has to be the exact type, we use an implementation detail here</span>
        <span class="c1">#             limits_coord.append(space.get_limits(obs=coord if using_obs else None,</span>
        <span class="c1">#                                                  axes=coord if not using_obs else None))</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             raise WorkInProgressError</span>
        <span class="c1">#             # limits_coord.append(space.with_obs(obs=coord) if using_obs else space.with_axes(axes=coord))</span>
        <span class="c1">#     any_non_equal = any([limits_coord[0][(coord,)] != limit[(coord,)] for limit in limits_coord[1:]])</span>
        <span class="c1">#     if any_non_equal:</span>
        <span class="c1">#         raise LimitsIncompatibleError(f&quot;Limits in coord {coord} do not match for spaces {limits_coord}&quot;)</span>
        <span class="c1">#     limits_dict.update(limits_coord[0])</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;obs&#39;</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="s1">&#39;axes&#39;</span><span class="p">:</span> <span class="n">limits_dict</span><span class="p">}</span>

    <span class="c1"># all_lower = []</span>
    <span class="c1"># all_upper = []</span>
    <span class="c1">#</span>
    <span class="c1"># # create the lower and upper limits with all obs replacing missing dims with None</span>
    <span class="c1"># # With this, all limits have the same length</span>
    <span class="c1"># # TODO?</span>
    <span class="c1"># # if limits_overlap(spaces=spaces, allow_exact_match=True):</span>
    <span class="c1"># #     raise LimitsIncompatibleError(&quot;Limits overlap&quot;)</span>
    <span class="c1">#</span>
    <span class="c1"># for space in flatten_spaces(spaces):</span>
    <span class="c1">#     if space.limits is None:</span>
    <span class="c1">#         continue</span>
    <span class="c1">#     lowers, uppers = space.limits</span>
    <span class="c1">#     lower = [tuple(low[space.obs.index(ob)] for low in lowers) if ob in space.obs else None for ob in all_obs]</span>
    <span class="c1">#     upper = [tuple(up[space.obs.index(ob)] for up in uppers) if ob in space.obs else None for ob in all_obs]</span>
    <span class="c1">#     all_lower.append(lower)</span>
    <span class="c1">#     all_upper.append(upper)</span>
    <span class="c1">#</span>
    <span class="c1"># def check_extract_limits(limits_spaces):</span>
    <span class="c1">#     new_limits = []</span>
    <span class="c1">#</span>
    <span class="c1">#     if not limits_spaces:</span>
    <span class="c1">#         return None</span>
    <span class="c1">#     for index, obs in enumerate(all_obs):</span>
    <span class="c1">#         current_limit = None</span>
    <span class="c1">#         for limit in limits_spaces:</span>
    <span class="c1">#             lim = limit[index]</span>
    <span class="c1">#</span>
    <span class="c1">#             if lim is not None:</span>
    <span class="c1">#                 if current_limit is None:</span>
    <span class="c1">#                     current_limit = lim</span>
    <span class="c1">#                 elif not np.allclose(current_limit, lim):</span>
    <span class="c1">#                     return False</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             if current_limit is None:</span>
    <span class="c1">#                 raise LimitsNotSpecifiedError(&quot;Limits in obs {} are not specified&quot;.format(obs))</span>
    <span class="c1">#             new_limits.append(current_limit)</span>
    <span class="c1">#</span>
    <span class="c1">#     n_limits = int(np.prod(tuple(len(lim) for lim in new_limits)))</span>
    <span class="c1">#     new_limits_comb = [[] for _ in range(n_limits)]</span>
    <span class="c1">#     for limit in new_limits:</span>
    <span class="c1">#         for lim in limit:</span>
    <span class="c1">#             for i in range(int(n_limits / len(limit))):</span>
    <span class="c1">#                 new_limits_comb[i].append(lim)</span>
    <span class="c1">#</span>
    <span class="c1">#     new_limits = tuple(tuple(limit) for limit in new_limits_comb)</span>
    <span class="c1">#     return new_limits</span>

    <span class="c1"># new_lower = check_extract_limits(all_lower)</span>
    <span class="c1"># new_upper = check_extract_limits(all_upper)</span>
    <span class="c1"># assert not (new_lower is None) ^ (new_upper is None), &quot;Bug, please report issue. either both are defined or None.&quot;</span>
    <span class="c1"># if new_lower is None:</span>
    <span class="c1">#     limits = None</span>
    <span class="c1"># elif new_lower is False:</span>
    <span class="c1">#     return False</span>
    <span class="c1"># else:</span>
    <span class="c1">#     limits = (new_lower, new_upper)</span>
    <span class="n">new_space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">common_obs_ordered</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">using_obs</span> <span class="k">else</span> <span class="n">common_axes_ordered</span><span class="p">,</span>
                      <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">)</span>
    <span class="c1"># if new_space.n_limits &gt; 1:</span>
    <span class="c1">#     new_space = MultiSpace(Space, obs=all_obs)</span>
    <span class="k">return</span> <span class="n">new_space</span></div>


<div class="viewcode-block" id="less_equal_space"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.less_equal_space">[docs]</a><span class="k">def</span> <span class="nf">less_equal_space</span><span class="p">(</span><span class="n">space1</span><span class="p">,</span> <span class="n">space2</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">compare_multispace</span><span class="p">(</span><span class="n">space1</span><span class="o">=</span><span class="n">space1</span><span class="p">,</span> <span class="n">space2</span><span class="o">=</span><span class="n">space2</span><span class="p">,</span>
                              <span class="n">comparator</span><span class="o">=</span><span class="k">lambda</span> <span class="n">limit1</span><span class="p">,</span> <span class="n">limit2</span><span class="p">:</span> <span class="n">limit1</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">limit2</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="n">allow_graph</span><span class="p">))</span></div>


<div class="viewcode-block" id="equal_space"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.equal_space">[docs]</a><span class="k">def</span> <span class="nf">equal_space</span><span class="p">(</span><span class="n">space1</span><span class="p">,</span> <span class="n">space2</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">compare_multispace</span><span class="p">(</span><span class="n">space1</span><span class="o">=</span><span class="n">space1</span><span class="p">,</span> <span class="n">space2</span><span class="o">=</span><span class="n">space2</span><span class="p">,</span>
                              <span class="n">comparator</span><span class="o">=</span><span class="k">lambda</span> <span class="n">limit1</span><span class="p">,</span> <span class="n">limit2</span><span class="p">:</span> <span class="n">limit1</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">limit2</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="n">allow_graph</span><span class="p">))</span></div>


<div class="viewcode-block" id="compare_multispace"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.compare_multispace">[docs]</a><span class="k">def</span> <span class="nf">compare_multispace</span><span class="p">(</span><span class="n">space1</span><span class="p">:</span> <span class="n">ZfitSpace</span><span class="p">,</span> <span class="n">space2</span><span class="p">:</span> <span class="n">ZfitSpace</span><span class="p">,</span> <span class="n">comparator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare multiple spaces if they have the same obs, axes, and, if a comparator is given, limits.</span>

<span class="sd">    It is automatically checked if the limits are set resp. are False</span>

<span class="sd">    Args:</span>
<span class="sd">        space1:</span>
<span class="sd">        space2:</span>
<span class="sd">        comparator:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axes_not_none</span> <span class="o">=</span> <span class="n">space1</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">space2</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">obs_not_none</span> <span class="o">=</span> <span class="n">space1</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">space2</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">axes_not_none</span> <span class="ow">or</span> <span class="n">obs_not_none</span><span class="p">):</span>  <span class="c1"># if both are None</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">obs_not_none</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">space1</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">space2</span><span class="o">.</span><span class="n">obs</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">axes_not_none</span><span class="p">:</span>  <span class="c1"># axes only matter if there are no obs</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">space1</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">space2</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># check limits</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">space1</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">space2</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="n">space1</span><span class="o">.</span><span class="n">limits_are_false</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">space2</span><span class="o">.</span><span class="n">limits_are_false</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">compare_limits_multispace</span><span class="p">(</span><span class="n">space1</span><span class="p">,</span> <span class="n">space2</span><span class="p">,</span> <span class="n">comparator</span><span class="o">=</span><span class="n">comparator</span><span class="p">)</span></div>


<div class="viewcode-block" id="compare_limits_multispace"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.compare_limits_multispace">[docs]</a><span class="k">def</span> <span class="nf">compare_limits_multispace</span><span class="p">(</span><span class="n">space1</span><span class="p">:</span> <span class="n">ZfitSpace</span><span class="p">,</span> <span class="n">space2</span><span class="p">:</span> <span class="n">ZfitSpace</span><span class="p">,</span> <span class="n">comparator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">space1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">space2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">space1</span><span class="o">.</span><span class="n">has_limits</span> <span class="ow">and</span> <span class="n">space2</span><span class="o">.</span><span class="n">has_limits</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">space2_reordered</span> <span class="o">=</span> <span class="n">space2</span><span class="o">.</span><span class="n">with_coords</span><span class="p">(</span><span class="n">space1</span><span class="p">)</span>

    <span class="n">comparison</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">space11</span> <span class="ow">in</span> <span class="n">space1</span><span class="p">:</span>
        <span class="n">compare_spaces2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">space22</span> <span class="ow">in</span> <span class="n">space2_reordered</span><span class="p">:</span>
            <span class="n">compare_spaces2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">compare_limits_coords_dict</span><span class="p">(</span><span class="n">space11</span><span class="o">.</span><span class="n">get_limits</span><span class="p">(),</span> <span class="n">space22</span><span class="o">.</span><span class="n">get_limits</span><span class="p">(),</span> <span class="n">comparator</span><span class="o">=</span><span class="n">comparator</span><span class="p">))</span>
        <span class="n">comparison</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compare_spaces2</span><span class="p">)</span>
    <span class="n">comparison</span> <span class="o">=</span> <span class="n">convert_to_tensor_or_numpy</span><span class="p">(</span><span class="n">comparison</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">space1_matches</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_any</span><span class="p">(</span><span class="n">comparison</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># reduce over axis containing space2, has to match with</span>
    <span class="c1"># at least one space2.</span>
    <span class="n">space2_matches</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_any</span><span class="p">(</span><span class="n">comparison</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">all_space1_match</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">space1_matches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">all_space2_match</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">space2_matches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">all_space1_match</span><span class="p">,</span> <span class="n">all_space2_match</span><span class="p">)</span></div>


<div class="viewcode-block" id="compare_limits_coords_dict"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.compare_limits_coords_dict">[docs]</a><span class="k">def</span> <span class="nf">compare_limits_coords_dict</span><span class="p">(</span><span class="n">limits1</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">]],</span>
                               <span class="n">limits2</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">ZfitLimit</span><span class="p">]],</span>
                               <span class="n">comparator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                               <span class="n">require_all_coord_types</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">limits1</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">limits2</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">require_all_coord_types</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">equal</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">coord_type</span><span class="p">,</span> <span class="n">limit1_dict</span> <span class="ow">in</span> <span class="n">limits1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">limit2_dict</span> <span class="o">=</span> <span class="n">limits2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">limit2_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">equal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compare_limits_dict</span><span class="p">(</span><span class="n">limit1_dict</span><span class="p">,</span> <span class="n">limit2_dict</span><span class="p">,</span> <span class="n">comparator</span><span class="o">=</span><span class="n">comparator</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">equal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="compare_limits_dict"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.compare_limits_dict">[docs]</a><span class="k">def</span> <span class="nf">compare_limits_dict</span><span class="p">(</span><span class="n">dict1</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">dict2</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">comparator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">comparison</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">limits2_to_check</span> <span class="o">=</span> <span class="n">dict2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">limit1</span> <span class="ow">in</span> <span class="n">dict1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">limit2cord</span><span class="p">,</span> <span class="n">limit2</span> <span class="ow">in</span> <span class="n">limits2_to_check</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">limit2cord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
                <span class="n">limit2</span> <span class="o">=</span> <span class="n">limits2_to_check</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">limit2cord</span><span class="p">)</span>
                <span class="n">comparison</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comparator</span><span class="p">(</span><span class="n">limit1</span><span class="p">,</span> <span class="n">limit2</span><span class="p">))</span>
                <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no break, nothing matched</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">unstable</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">comparison</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="flatten_spaces"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.flatten_spaces">[docs]</a><span class="k">def</span> <span class="nf">flatten_spaces</span><span class="p">(</span><span class="n">spaces</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">space</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiSpace"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace">[docs]</a><span class="k">class</span> <span class="nc">MultiSpace</span><span class="p">(</span><span class="n">BaseSpace</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                <span class="n">spaces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ZfitSpace</span><span class="p">],</span>
                <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="s1">&#39;Space&#39;</span><span class="p">,</span> <span class="s1">&#39;MultiSpace&#39;</span><span class="p">]:</span>
        <span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_check_convert_input_spaces_obs_axes</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">space</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="c1"># for the __init__ below, see there</span>
        <span class="n">space</span><span class="o">.</span><span class="n">_tmp_store_spaces_obs_axes</span> <span class="o">=</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span>

        <span class="k">return</span> <span class="n">space</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spaces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ZfitSpace</span><span class="p">],</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Since __new__ returns an instance of MultiSpace, __init__ is invoked. We don&#39;t want to reprocess</span>
        <span class="c1"># the input arguments here, so we store them above in the dummy attribute.</span>
        <span class="k">del</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span>  <span class="c1"># not needed, we take the already preprocessed.</span>
        <span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_store_spaces_obs_axes</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_store_spaces_obs_axes</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;MultiSpace&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span> <span class="o">=</span> <span class="n">spaces</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_initialize_space</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="n">space</span><span class="o">.</span><span class="n">_obs</span> <span class="o">=</span> <span class="n">obs</span>
        <span class="n">space</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="n">space</span><span class="o">.</span><span class="n">spaces</span> <span class="o">=</span> <span class="n">spaces</span>
        <span class="k">return</span> <span class="n">space</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_convert_input_spaces_obs_axes</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>  <span class="c1"># TODO: do something with axes</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="n">flatten_spaces</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">all_have_obs</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)</span>
        <span class="n">all_have_axes</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)</span>
        <span class="n">n_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">n_events</span> <span class="ow">in</span> <span class="p">(</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_events</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
        <span class="n">all_nevents_compatible</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">n_events</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_nevents_compatible</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NumberOfEventsIncompatibleError</span><span class="p">(</span><span class="s2">&quot;The number of events of the spaces do not coincide&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_have_axes</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">convert_to_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">all_have_obs</span><span class="p">:</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span> <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">convert_to_obs_str</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
            <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">all_have_axes</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">axes</span> <span class="o">==</span> <span class="n">axes</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)):</span>  <span class="c1"># obs coincide, axes don&#39;t -&gt; drop</span>
                <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">all_have_axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
                <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">all_have_obs</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="o">==</span> <span class="n">obs</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)):</span>  <span class="c1"># axes coincide, obs don&#39;t -&gt; drop</span>
                <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SpaceIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Spaces do not have consistent obs and/or axes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">has_limits</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
            <span class="c1"># check overlap, reduce common limits</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">has_limits</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
            <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># if all are None, then nothing to add</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># some have limits, some don&#39;t -&gt; does not really make sense (or just drop the ones without limits?)</span>
            <span class="k">raise</span> <span class="n">LimitsIncompatibleError</span><span class="p">(</span>
                <span class="s2">&quot;Some spaces have limits, other don&#39;t. This behavior may change in the future &quot;</span>
                <span class="s2">&quot;to allow spaces with None to be simply ignored.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;If you prefer this behavior, please open an issue on github.&quot;</span><span class="p">)</span>

        <span class="n">spaces</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">axes</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits_np</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_limits_not_implemented</span><span class="p">()</span>

<div class="viewcode-block" id="MultiSpace.rect_area"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.rect_area">[docs]</a>    <span class="k">def</span> <span class="nf">rect_area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the total rectangular area of all the limits and axes. Useful, for example, for MC integration.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">rect_area</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rect_limits_are_tensors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True if the rectangular limits are tensors.</span>

<span class="sd">        If a limit with tensors is evaluated inside a graph context, comparison operations will fail.</span>

<span class="sd">        Returns:</span>
<span class="sd">            If the rectangular limits are tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">limits_are_tensors</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_rect_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If there are limits and whether they are rectangular.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">has_rect_limits</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits_are_false</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If the limits have been set to False, so the object on purpose does not contain limits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if limits is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">limits_are_false</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="c1"># noinspection PyPropertyDefinition</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether there are limits set and they are not false.</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_set</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits_are_false</span>
        <span class="k">except</span> <span class="n">MultipleLimitsNotImplementedError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits_are_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If the limits have been set to a limit or are False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether the limits have been set or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">limits_are_set</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Shape of the first dimension, usually reflects the number of events.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Return the number of events, the dimension of the first shape. If this is &gt; 1 or None,</span>
<span class="sd">                it&#39;s vectorized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the first numeric n_events. Is None if a Tensor and not specified yet.</span>
        <span class="n">n_events_first</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">n_events</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">space</span><span class="o">.</span><span class="n">n_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">n_events</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">n_events_first</span> <span class="k">else</span> <span class="n">n_events_first</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">n_events</span>

<div class="viewcode-block" id="MultiSpace.with_limits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.with_limits">[docs]</a>    <span class="k">def</span> <span class="nf">with_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">limits</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">rect_limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">RectLimitsInputType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZfitSpace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the space with the new `limits` (and the new `name`).</span>

<span class="sd">        Args:</span>
<span class="sd">            limits: Limits to use. Can be rectangular, a function (requires to also specify `rect_limits`</span>
<span class="sd">                or an instance of ZfitLimit.</span>
<span class="sd">            rect_limits: Rectangular limits that will be assigned with the instance</span>
<span class="sd">            name: Human readable name</span>

<span class="sd">        Returns:</span>
<span class="sd">            Copy of the current object with the new limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">,</span> <span class="n">rect_limits</span><span class="o">=</span><span class="n">rect_limits</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

<div class="viewcode-block" id="MultiSpace.area"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.area">[docs]</a>    <span class="nd">@warn_or_fail_not_rect</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect_area</span><span class="p">()</span></div>

<div class="viewcode-block" id="MultiSpace.with_obs"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.with_obs">[docs]</a>    <span class="k">def</span> <span class="nf">with_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span><span class="p">],</span>
                 <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultiSpace&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new Space that has `obs`; sorted by or set or dropped.</span>

<span class="sd">        The behavior is as follows:</span>

<span class="sd">         * obs are already set:</span>
<span class="sd">           * input obs are None: the observables will be dropped. If no axes are set, an error</span>
<span class="sd">             will be raised, as no coordinates will be assigned to this instance anymore.</span>
<span class="sd">           * input obs are not None: the instance will be sorted by the incoming obs. If axes or other</span>
<span class="sd">             objects have an associated order (e.g. data, limits,...), they will be reordered as well.</span>
<span class="sd">             If a strict subset is given (and allow_subset is True), only a subset will be returned.</span>
<span class="sd">             This can be used to take a subspace of limits, data etc.</span>
<span class="sd">             If a strict superset is given (and allow_superset is True), the obs will be sorted accordingly as</span>
<span class="sd">             if the obs not contained in the instances obs were not in the input obs.</span>
<span class="sd">         * obs are not set:</span>
<span class="sd">           * if the input obs are None, the same object is returned.</span>
<span class="sd">           * if the input obs are not None, they will be set as-is and now correspond to the already</span>
<span class="sd">             existing axes in the object.</span>

<span class="sd">        Args:</span>
<span class="sd">            obs: Observables to sort/associate this instance with</span>
<span class="sd">            allow_superset: if False and a strict superset of the own observables is given, an error</span>
<span class="sd">            is raised.</span>
<span class="sd">            allow_subset:if False and a strict subset of the own observables is given, an error</span>
<span class="sd">            is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the object with the new ordering/observables</span>

<span class="sd">        Raises:</span>
<span class="sd">            CoordinatesUnderdefinedError: if obs is None and the instance does not have axes</span>
<span class="sd">            ObsIncompatibleError: if `obs` is a superset and allow_superset is False or a subset and</span>
<span class="sd">                allow_allow_subset is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.with_axes"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.with_axes">[docs]</a>    <span class="k">def</span> <span class="nf">with_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span><span class="p">],</span>
                  <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultiSpace&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance that has `axes`; sorted by or set or dropped.</span>

<span class="sd">            The behavior is as follows:</span>

<span class="sd">             * axes are already set:</span>
<span class="sd">               * input axes are None: the axes will be dropped. If no observables are set, an error</span>
<span class="sd">                 will be raised, as no coordinates will be assigned to this instance anymore.</span>
<span class="sd">               * input axes are not None: the instance will be sorted by the incoming axes. If obs or other</span>
<span class="sd">                 objects have an associated order (e.g. data, limits,...), they will be reordered as well.</span>
<span class="sd">                 If a strict subset is given (and allow_subset is True), only a subset will be returned. This can</span>
<span class="sd">                 be used to retrieve a subspace of limits, data etc.</span>
<span class="sd">                 If a strict superset is given (and allow_superset is True), the axes will be sorted accordingly as</span>
<span class="sd">                 if the axes not contained in the instances axes were not present in the input axes.</span>
<span class="sd">             * axes are not set:</span>
<span class="sd">               * if the input axes are None, the same object is returned.</span>
<span class="sd">               * if the input axes are not None, they will be set as-is and now correspond to the already</span>
<span class="sd">                 existing obs in the object.</span>

<span class="sd">            Args:</span>
<span class="sd">                axes: Axes to sort/associate this instance with</span>
<span class="sd">                allow_superset: if False and a strict superset of the own axeservables is given, an error</span>
<span class="sd">                is raised.</span>
<span class="sd">                allow_subset:if False and a strict subset of the own axeservables is given, an error</span>
<span class="sd">                is raised.</span>

<span class="sd">            Returns:</span>
<span class="sd">                A copy of the object with the new ordering/axes</span>
<span class="sd">            Raises:</span>
<span class="sd">                CoordinatesUnderdefinedError: if obs is None and the instance does not have axes</span>
<span class="sd">                AxesIncompatibleError: if `axes` is a superset and allow_superset is False or a subset and</span>
<span class="sd">                    allow_allow_subset is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">with_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.with_coords"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.with_coords">[docs]</a>    <span class="k">def</span> <span class="nf">with_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">coords</span><span class="p">:</span> <span class="n">ZfitOrderableDimensional</span><span class="p">,</span>
                    <span class="n">allow_superset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">allow_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultiSpace&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new :py:class:`~zfit.Space` with reordered observables and/or axes.</span>

<span class="sd">        The behavior is that _at least one coordinate (obs or axes) has to be set in both instances</span>
<span class="sd">        (the space itself or in `coords`). If both match, observables is taken as the defining coordinate.</span>
<span class="sd">        The space is sorted according to the defining coordinate and the other coordinate is sorted as well.</span>
<span class="sd">        If either the space did not have the &quot;weaker coordinate&quot; (e.g. both have observables, but only coords</span>
<span class="sd">        has axes), then the resulting Space will have both.</span>
<span class="sd">        If both have both coordinates, obs and axes, and sorting for obs results in non-matchin axes results</span>
<span class="sd">        in axes being dropped.</span>

<span class="sd">        Args:</span>
<span class="sd">            coords: An instance of :py:class:`Coordinates`</span>
<span class="sd">            allow_superset: If false and a strict superset is given, an error is raised</span>
<span class="sd">            allow_subset: If false and a strict subset is given, an error is raised</span>

<span class="sd">        Returns:</span>
<span class="sd">            :py:class:`~zfit.Space`:</span>
<span class="sd">        Raises:</span>
<span class="sd">            CoordinatesUnderdefinedError: if neither both obs or axes are specified.</span>
<span class="sd">            CoordinatesIncompatibleError: if `coords` is a superset and allow_superset is False or a subset and</span>
<span class="sd">                allow_allow_subset is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">allow_superset</span><span class="o">=</span><span class="n">allow_superset</span><span class="p">,</span> <span class="n">allow_subset</span><span class="o">=</span><span class="n">allow_subset</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">spaces</span><span class="o">=</span><span class="n">new_spaces</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.with_autofill_axes"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.with_autofill_axes">[docs]</a>    <span class="k">def</span> <span class="nf">with_autofill_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultiSpace&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Overwrite the axes of the current object with axes corresponding to range(len(n_obs)).</span>

<span class="sd">        This effectively fills with (0, 1, 2,...) and can be used mostly when an object enters a PDF or</span>
<span class="sd">        similar. `overwrite` allows to remove the axis first in case there are already some set.</span>

<span class="sd">        .. code-block::</span>

<span class="sd">            object.obs -&gt; (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>
<span class="sd">            object.axes -&gt; None</span>

<span class="sd">            object.with_autofill_axes()</span>

<span class="sd">            object.obs -&gt; (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>
<span class="sd">            object.axes -&gt; (0, 1, 2)</span>


<span class="sd">        Args:</span>
<span class="sd">            overwrite: If axes are already set, replace the axes with the autofilled ones.</span>
<span class="sd">                If axes is already set and `overwrite` is False, raise an error.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The object with the new axes</span>

<span class="sd">        Raises:</span>
<span class="sd">            AxesIncompatibleError: if the axes are already set and `overwrite` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_autofill_axes</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.iter_limits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.iter_limits">[docs]</a>    <span class="k">def</span> <span class="nf">iter_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span><span class="p">(</span><span class="s2">&quot;This should not be used anymore&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.iter_areas"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.iter_areas">[docs]</a>    <span class="k">def</span> <span class="nf">iter_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">BreakingAPIChangeError</span><span class="p">(</span><span class="s2">&quot;This should not be used anymore&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.get_subspace"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.get_subspace">[docs]</a>    <span class="k">def</span> <span class="nf">get_subspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">obs</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">axes</span><span class="p">:</span> <span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultiSpace&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a :py:class:`~zfit.Space` consisting of only a subset of the `obs`/`axes` (only one allowed).</span>

<span class="sd">        Args:</span>
<span class="sd">            obs: Observables of the subspace to return.</span>
<span class="sd">            axes: Axes of the subspace to return.</span>
<span class="sd">            name: Human readable names</span>

<span class="sd">        Returns:</span>
<span class="sd">            A space containing only a subspace (and sublimits etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">get_subspace</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSpace.copy"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.MultiSpace.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">overwrite_params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultiSpace&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">,</span> <span class="s2">&quot;deep not explicitly implemented, should not be needed for immutable objects&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">spaces</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overwrite_params</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_space</span></div>

    <span class="k">def</span> <span class="nf">_raise_limits_not_implemented</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MultipleLimitsNotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Limits/lower/upper not implemented for MultiSpace. This error is either caught&quot;</span>
            <span class="s2">&quot; automatically as part of the codes logic or the MultiLimit case should&quot;</span>
            <span class="s2">&quot; be considered. To do that, simply iterate through the MultiSpace, which returns&quot;</span>
            <span class="s2">&quot; a simple space. Iterating through a Spaces also works&quot;</span>
            <span class="s2">&quot;for simple spaces.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="p">):</span>
        <span class="n">inside_limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">guarantee_limits</span><span class="o">=</span><span class="n">guarantee_limits</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_any</span><span class="p">(</span><span class="n">input_tensor</span><span class="o">=</span><span class="n">inside_limits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># has to be inside one limit</span>
        <span class="k">return</span> <span class="n">inside</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZfitSpace</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MultipleLimitsNotImplementedError</span>
        <span class="n">all_equal</span> <span class="o">=</span> <span class="n">equal_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_equal</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MultipleLimitsNotImplementedError</span>
        <span class="n">all_less_equal</span> <span class="o">=</span> <span class="n">less_equal_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">allow_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_less_equal</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_to_space"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.convert_to_space">[docs]</a><span class="k">def</span> <span class="nf">convert_to_space</span><span class="p">(</span><span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">ObsTypeInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">AxesTypeInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ztyping</span><span class="o">.</span><span class="n">LimitsTypeInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="o">*</span><span class="p">,</span> <span class="n">overwrite_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">one_dim_limits_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">simple_limits_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Convert *limits* to a :py:class:`~zfit.Space` object if not already None or False.</span>

<span class="sd">    Args:</span>
<span class="sd">        obs:</span>
<span class="sd">        limits:</span>
<span class="sd">        axes:</span>
<span class="sd">        overwrite_limits: If `obs` or `axes` is a :py:class:`~zfit.Space` _and_ `limits` are given, return an instance</span>
<span class="sd">            of :py:class:`~zfit.Space` with the new limits. If the flag is `False`, the `limits` argument will be</span>
<span class="sd">            ignored if</span>
<span class="sd">        one_dim_limits_only:</span>
<span class="sd">        simple_limits_only:</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[:py:class:`~zfit.Space`, False, None]:</span>

<span class="sd">    Raises:</span>
<span class="sd">        OverdefinedError: if `obs` or `axes` is a :py:class:`~zfit.Space` and `axes` respectively `obs` is not `None`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">space</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Test if already `Space` and handle</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OverdefinedError</span><span class="p">(</span><span class="s2">&quot;if `obs` is a `Space`, `axes` cannot be defined.&quot;</span><span class="p">)</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">obs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OverdefinedError</span><span class="p">(</span><span class="s2">&quot;if `axes` is a `Space`, `obs` cannot be defined.&quot;</span><span class="p">)</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">limits</span>
    <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># set the limits if given</span>
        <span class="k">if</span> <span class="n">limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">overwrite_limits</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">space</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>  <span class="c1"># figure out if compatible if limits is `Space`</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">limits</span><span class="o">.</span><span class="n">obs</span> <span class="o">==</span> <span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">limits</span><span class="o">.</span><span class="n">axes</span> <span class="o">==</span> <span class="n">space</span><span class="o">.</span><span class="n">axes</span> <span class="ow">and</span> <span class="n">limits</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">IntentionAmbiguousError</span><span class="p">(</span>
                        <span class="s2">&quot;`obs`/`axes` is a `Space` as well as the `limits`, but the &quot;</span>
                        <span class="s2">&quot;obs/axes of them do not match&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">limits</span><span class="o">.</span><span class="n">limits_are_false</span><span class="p">:</span>
                    <span class="n">limits</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">limits</span> <span class="o">=</span> <span class="n">limits</span><span class="o">.</span><span class="n">limits</span>

            <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">with_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">space</span>

    <span class="c1"># space is None again</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># check if limits are allowed</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">)</span>  <span class="c1"># create and test if valid</span>
        <span class="k">if</span> <span class="n">one_dim_limits_only</span> <span class="ow">and</span> <span class="n">space</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">space</span><span class="o">.</span><span class="n">has_limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsUnderdefinedError</span><span class="p">(</span>
                <span class="s2">&quot;Limits more sophisticated than 1-dim cannot be auto-created from tuples. Use `Space` instead.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simple_limits_only</span> <span class="ow">and</span> <span class="n">space</span><span class="o">.</span><span class="n">has_limits</span> <span class="ow">and</span> <span class="n">space</span><span class="o">.</span><span class="n">n_limits</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LimitsUnderdefinedError</span><span class="p">(</span><span class="s2">&quot;Limits with multiple limits cannot be auto-created&quot;</span>
                                          <span class="s2">&quot; from tuples. Use `Space` instead.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">space</span></div>


<div class="viewcode-block" id="no_norm_range"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.no_norm_range">[docs]</a><span class="k">def</span> <span class="nf">no_norm_range</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator: Catch the &#39;norm_range&#39; kwargs. If not None, raise NormRangeNotImplementedError.&quot;&quot;&quot;</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="s1">&#39;norm_range&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">norm_range_index</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;norm_range&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">norm_range_index</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">new_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">norm_range</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm_range&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm_range</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">):</span>
            <span class="n">norm_range_not_false</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">norm_range</span><span class="o">.</span><span class="n">limits_are_false</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_range_not_false</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">norm_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">norm_range</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm_range_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm_range_is_arg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">norm_range_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_range_is_arg</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm_range&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># remove if in signature (= norm_range_index not None)</span>
        <span class="k">if</span> <span class="n">norm_range_not_false</span> <span class="ow">or</span> <span class="n">norm_range_is_arg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NormRangeNotImplementedError</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_func</span></div>


<div class="viewcode-block" id="no_multiple_limits"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.no_multiple_limits">[docs]</a><span class="k">def</span> <span class="nf">no_multiple_limits</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator: Catch the &#39;limits&#39; kwargs. If it contains multiple limits, raise MultipleLimitsNotImplementedError.&quot;&quot;&quot;</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="s1">&#39;limits&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">limits_index</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;limits&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span>  <span class="c1"># no limits as parameters -&gt; no problem</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">new_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">limits_is_arg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limits_index</span>
        <span class="k">if</span> <span class="n">limits_is_arg</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">limits_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;limits&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">limits</span><span class="o">.</span><span class="n">n_limits</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MultipleLimitsNotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_func</span></div>


<div class="viewcode-block" id="supports"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.supports">[docs]</a><span class="k">def</span> <span class="nf">supports</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">norm_range</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">multiple_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Decorator: Add (mandatory for some methods) on a method to control what it can handle.</span>

<span class="sd">    If any of the flags is set to False, it will check the arguments and, in case they match a flag</span>
<span class="sd">    (say if a *norm_range* is passed while the *norm_range* flag is set to `False`), it will</span>
<span class="sd">    raise a corresponding exception (in this example a `NormRangeNotImplementedError`) that will</span>
<span class="sd">    be catched by an earlier function that knows how to handle things.</span>

<span class="sd">    Args:</span>
<span class="sd">        norm_range: If False, no norm_range argument will be passed through resp. will be `None`</span>
<span class="sd">        multiple_limits: If False, only simple limits are to be expected and no iteration is</span>
<span class="sd">            therefore required.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decorator_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">multiple_limits</span><span class="p">:</span>
        <span class="n">decorator_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">no_multiple_limits</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">norm_range</span><span class="p">:</span>
        <span class="n">decorator_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">no_norm_range</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_deco_stack</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">decorator</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">decorator_stack</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">supports</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">return</span> <span class="n">create_deco_stack</span></div>


<div class="viewcode-block" id="contains_tensor"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.contains_tensor">[docs]</a><span class="k">def</span> <span class="nf">contains_tensor</span><span class="p">(</span><span class="n">objects</span><span class="p">):</span>
    <span class="n">tensor_found</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tensor_found</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">tensor_found</span> <span class="o">+=</span> <span class="n">contains_tensor</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tensor_found</span></div>


<div class="viewcode-block" id="shape_np_tf"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.shape_np_tf">[docs]</a><span class="k">def</span> <span class="nf">shape_np_tf</span><span class="p">(</span><span class="n">objects</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">contains_tensor</span><span class="p">(</span><span class="n">objects</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shape</span></div>


<div class="viewcode-block" id="limits_consistent"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.limits_consistent">[docs]</a><span class="k">def</span> <span class="nf">limits_consistent</span><span class="p">(</span><span class="n">spaces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;zfit.Space&quot;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Check if space limits are the *exact* same in each obs they are defined and therefore are compatible.</span>

<span class="sd">    In this case, if a space has several limits, e.g. from -1 to 1 and from 2 to 3 (all in the same observable),</span>
<span class="sd">    to be consistent with this limits, other limits have to have (in this obs) also the limits</span>
<span class="sd">    from -1 to 1 and from 2 to 3. Only having the limit -1 to 1 _or_ 2 to 3 is considered _not_ consistent.</span>

<span class="sd">    This function is useful to check if several spaces with *different* observables can be _combined_.</span>

<span class="sd">    Args:</span>
<span class="sd">        spaces:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">new_space</span> <span class="o">=</span> <span class="n">combine_spaces</span><span class="p">(</span><span class="o">*</span><span class="n">spaces</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">LimitsIncompatibleError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="add_spaces_old"><a class="viewcode-back" href="../../../full_api/zfit.core.space.html#zfit.add_spaces_old">[docs]</a><span class="k">def</span> <span class="nf">add_spaces_old</span><span class="p">(</span><span class="n">spaces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;zfit.Space&quot;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Add two spaces and merge their limits if possible or return False.</span>

<span class="sd">    Args:</span>
<span class="sd">        spaces:</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[None, :py:class:`~zfit.Space`, bool]:</span>

<span class="sd">    Raises:</span>
<span class="sd">        LimitsIncompatibleError: if limits of the `spaces` cannot be merged because they overlap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">convert_to_container</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ZfitSpace</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot only add type ZfitSpace&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least two spaces to be added.&quot;</span><span class="p">)</span>  <span class="c1"># TODO: allow? usecase?</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">obs1</span> <span class="o">=</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">with_obs</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs1</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">space</span><span class="o">.</span><span class="n">obs</span> <span class="o">==</span> <span class="n">obs1</span> <span class="k">else</span> <span class="n">space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">limits_overlap</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="n">spaces</span><span class="p">,</span> <span class="n">allow_exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">LimitsIncompatibleError</span><span class="p">(</span><span class="s2">&quot;Limits of spaces overlap, cannot merge spaces.&quot;</span><span class="p">)</span>

    <span class="n">lowers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">uppers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">space</span><span class="o">.</span><span class="n">limits_are_set</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="ow">in</span> <span class="n">space</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">other_lower</span><span class="p">,</span> <span class="n">other_upper</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">):</span>
                <span class="n">lower_same</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">other_lower</span><span class="p">)</span>
                <span class="n">upper_same</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">other_upper</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">lower_same</span> <span class="o">^</span> <span class="n">upper_same</span><span class="p">,</span> <span class="s2">&quot;Bug, please report as issue. limits_overlap did not catch right.&quot;</span>
                <span class="k">if</span> <span class="n">lower_same</span> <span class="ow">and</span> <span class="n">upper_same</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lowers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
                <span class="n">uppers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="n">lowers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lowers</span><span class="p">)</span>
    <span class="n">uppers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">uppers</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lowers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span>
    <span class="n">new_space</span> <span class="o">=</span> <span class="n">zfit</span><span class="o">.</span><span class="n">Space</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_space</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../../_static/js/index.30270b6e4c972e43c488.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright Copyright 2018, zfit.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>