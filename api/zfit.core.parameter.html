<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>parameter &#8212; zfit 0.3.3 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="sample" href="zfit.core.sample.html" />
    <link rel="prev" title="operations" href="zfit.core.operations.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-2.3.2/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="brand" href="../index.html">
          zfit</a>
        <span class="navbar-text pull-left"><b>0.3.3</b></span>

        <div class="nav-collapse">
          <ul class="nav">
            <li class="divider-vertical"></li>
            
                <li><a href="../getting_started.html">Getting started</a></li>
                <li><a href="../space.html">Space</a></li>
                <li><a href="../parameter.html">Parameter</a></li>
                <li><a href="../model.html">Model</a></li>
                <li><a href="../data.html">Data</a></li>
                <li><a href="../loss.html">Loss</a></li>
                <li><a href="../minimize.html">Minimize</a></li>
                <li><a href="../API.html">API</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started with zfit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../downloading.html">Downloading and Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../space.html">Space, Observable and Range</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parameter.html">Parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model.html">Building a model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loss.html">Loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="../minimize.html">Minimization</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../API.html">zfit API documentation</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
      </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body span12 content" role="main">
      
  <div class="section" id="module-zfit.core.parameter">
<span id="parameter"></span><h1>parameter<a class="headerlink" href="#module-zfit.core.parameter" title="Permalink to this headline">¶</a></h1>
<p>Define Parameter which holds the value.</p>
<dl class="class">
<dt id="zfit.core.parameter.BaseComposedParameter">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">BaseComposedParameter</code><span class="sig-paren">(</span><em>params</em>, <em>value</em>, <em>name='BaseComposedParameter'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#BaseComposedParameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#zfit.core.parameter.ZfitParameterMixin" title="zfit.core.parameter.ZfitParameterMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.ZfitParameterMixin</span></code></a>, <a class="reference internal" href="#zfit.core.parameter.ComposedVariable" title="zfit.core.parameter.ComposedVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.ComposedVariable</span></code></a>, <a class="reference internal" href="#zfit.core.parameter.BaseParameter" title="zfit.core.parameter.BaseParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.BaseParameter</span></code></a></p>
<dl class="class">
<dt id="zfit.core.parameter.BaseComposedParameter.SaveSliceInfo">
<em class="property">class </em><code class="descname">SaveSliceInfo</code><span class="sig-paren">(</span><em>full_name=None</em>, <em>full_shape=None</em>, <em>var_offset=None</em>, <em>var_shape=None</em>, <em>save_slice_info_def=None</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.SaveSliceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Information on how to save this Variable as a slice.</p>
<p>Provides internal support for saving variables as slices of a larger
variable.  This API is not public and is subject to change.</p>
<p>Available properties:</p>
<ul class="simple">
<li><p>full_name</p></li>
<li><p>full_shape</p></li>
<li><p>var_offset</p></li>
<li><p>var_shape</p></li>
</ul>
<p>Create a <cite>SaveSliceInfo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_name</strong> – Name of the full variable of which this <cite>Variable</cite> is a
slice.</p></li>
<li><p><strong>full_shape</strong> – Shape of the full variable, as a list of int.</p></li>
<li><p><strong>var_offset</strong> – Offset of this <cite>Variable</cite> into the full variable, as a
list of int.</p></li>
<li><p><strong>var_shape</strong> – Shape of this <cite>Variable</cite>, as a list of int.</p></li>
<li><p><strong>save_slice_info_def</strong> – <cite>SaveSliceInfoDef</cite> protocol buffer. If not <cite>None</cite>,
recreates the SaveSliceInfo object its contents.
<cite>save_slice_info_def</cite> and other arguments are mutually
exclusive.</p></li>
<li><p><strong>import_scope</strong> – Optional <cite>string</cite>. Name scope to add. Only used
when initializing from protocol buffer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.SaveSliceInfo.spec">
<code class="descname">spec</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.SaveSliceInfo.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the spec string used for saving.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.SaveSliceInfo.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.SaveSliceInfo.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SaveSliceInfoDef() proto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>SaveSliceInfoDef</cite> protocol buffer, or None if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy method to prevent iteration. Do not call.</p>
<p>NOTE(mrry): If we register __getitem__ as an overloaded operator,
Python will valiantly attempt to iterate over the variable’s Tensor from 0
to infinity.  Declaring this method prevents this unintended behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – when invoked.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.add_cache_dependents">
<code class="descname">add_cache_dependents</code><span class="sig-paren">(</span><em>cache_dependents: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]], allow_non_cachable: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.add_cache_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dependents that render the cache invalid if they change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cache_dependents</strong> (<a class="reference internal" href="zfit.util.cache.html#zfit.util.cache.ZfitCachable" title="zfit.util.cache.ZfitCachable"><em>ZfitCachable</em></a>) – </p></li>
<li><p><strong>allow_non_cachable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, allow <cite>cache_dependents</cite> to be non-cachables.
If <cite>False</cite>, any <cite>cache_dependents</cite> that is not a <cite>ZfitCachable</cite> will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – if one of the <cite>cache_dependents</cite> is not a <cite>ZfitCachable</cite> _and_ <cite>allow_non_cachable</cite>
    if <cite>False</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=False</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a new value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – A <cite>Tensor</cite>. The new value for this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the assignment.</p></li>
<li><p><strong>name</strong> – The name to use for the assignment.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.assign_add">
<code class="descname">assign_add</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.assign_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to add to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.assign_sub">
<code class="descname">assign_sub</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.assign_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts a value from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to subtract from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.batch_scatter_update">
<code class="descname">batch_scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.batch_scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable batch-wise.</p>
<p>Analogous to <cite>batch_gather</cite>. This assumes that this variable and the
sparse_delta IndexedSlices have a series of leading dimensions that are the
same for all of them, and the updates are performed on the last dimension of
indices. In other words, the dimensions should be the following:</p>
<p><cite>num_prefix_dims = sparse_delta.indices.ndims - 1</cite>
<cite>batch_dim = num_prefix_dims + 1</cite>
<a href="#id1"><span class="problematic" id="id2">`</span></a>sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[</p>
<blockquote>
<div><p>batch_dim:]`</p>
</div></blockquote>
<p>where</p>
<p><cite>sparse_delta.updates.shape[:num_prefix_dims]</cite>
<cite>== sparse_delta.indices.shape[:num_prefix_dims]</cite>
<cite>== var.shape[:num_prefix_dims]</cite></p>
<p>And the operation performed can be expressed as:</p>
<dl class="simple">
<dt><a href="#id3"><span class="problematic" id="id4">`</span></a>var[i_1, …, i_n,</dt><dd><dl class="simple">
<dt>sparse_delta.indices[i_1, …, i_n, j]] = sparse_delta.updates[</dt><dd><p>i_1, …, i_n, j]`</p>
</dd>
</dl>
</dd>
</dl>
<p>When sparse_delta.indices is a 1D tensor, this operation is equivalent to
<cite>scatter_update</cite>.</p>
<p>To avoid this operation one can looping over the first <cite>ndims</cite> of the
variable and using <cite>scatter_update</cite> on the subtensors that result of slicing
the first dimension. This is a valid option for <cite>ndims = 1</cite>, but less
efficient than this implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.constraint">
<code class="descname">constraint</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the constraint function associated with this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint function that was passed to the variable constructor.
Can be <cite>None</cite> if no constraint was passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep: bool = False</em>, <em>name: str = None</em>, <em>**overwrite_params</em><span class="sig-paren">)</span> &#x2192; zfit.core.interfaces.ZfitObject<a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.count_up_to">
<code class="descname">count_up_to</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.count_up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments this variable until it reaches <cite>limit</cite>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Prefer Dataset.range instead.</p>
<p>When that Op is run it tries to increment the variable by <cite>1</cite>. If
incrementing the variable would bring it above <cite>limit</cite> then the Op raises
the exception <cite>OutOfRangeError</cite>.</p>
<p>If no error is raised, the Op outputs the value of the variable before
the increment.</p>
<p>This is essentially a shortcut for <cite>count_up_to(self, limit)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>limit</strong> – value at which incrementing the variable raises an error.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the variable value before the increment. If no
other Op modifies this variable, the values produced will all be
distinct.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.create">
<code class="descname">create</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.create" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.device">
<code class="descname">device</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The device this variable is on.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the object</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and returns the value of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.floating">
<code class="descname">floating</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.floating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.BaseComposedParameter.from_proto">
<em class="property">static </em><code class="descname">from_proto</code><span class="sig-paren">(</span><em>variable_def</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.from_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>Variable</cite> object created from <cite>variable_def</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.get_dependents">
<code class="descname">get_dependents</code><span class="sig-paren">(</span><em>only_floating: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[zfit.core.parameter.Parameter]<a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.get_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of all independent <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> that this object depends on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>only_floating</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, only return floating <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>only_floating: bool = False, names: Union[str, List[str], None] = None</em><span class="sig-paren">)</span> &#x2192; List[zfit.core.interfaces.ZfitParameter]<a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters. If it is empty, automatically return all floating variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>)</strong> (<em>names</em>) – If True, return only the floating parameters.</p></li>
<li><p><strong>(</strong><strong>)</strong> – The names of the parameters to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(<cite>ZfitParameters</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of Variable.shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.graph">
<code class="descname">graph</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Graph</cite> of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.handle">
<code class="descname">handle</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle by which this variable can be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.independent">
<code class="descname">independent</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.independent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.initial_value">
<code class="descname">initial_value</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Tensor used as the initial value for the variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.initialized_value">
<code class="descname">initialized_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.initialized_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the initialized variable.</p>
<p>You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">'v'</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">random</span> <span class="pre">tensor.</span>
<span class="pre">v</span> <span class="pre">=</span> <span class="pre">tf.Variable(tf.truncated_normal([10,</span> <span class="pre">40]))</span>
<span class="pre">#</span> <span class="pre">Use</span> <span class="pre">`initialized_value`</span> <span class="pre">to</span> <span class="pre">guarantee</span> <span class="pre">that</span> <span class="pre">`v`</span> <span class="pre">has</span> <span class="pre">been</span>
<span class="pre">#</span> <span class="pre">initialized</span> <span class="pre">before</span> <span class="pre">its</span> <span class="pre">value</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">initialize</span> <span class="pre">`w`.</span>
<span class="pre">#</span> <span class="pre">The</span> <span class="pre">random</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">picked</span> <span class="pre">only</span> <span class="pre">once.</span>
<span class="pre">w</span> <span class="pre">=</span> <span class="pre">tf.Variable(v.initialized_value()</span> <span class="pre">*</span> <span class="pre">2.0)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Tensor</cite> holding the value of this variable after its initializer
has run.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.is_initialized">
<code class="descname">is_initialized</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.is_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a resource variable has been initialized.</p>
<p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – A name for the operation (optional).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> of type <cite>bool</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>value</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load new value into this variable.</p>
<p>Writes new value to variable’s memory. Doesn’t add ops to the graph.</p>
<p>This convenience method requires a session where the graph
containing this variable has been launched. If no session is
passed, the default session is used.  See <cite>tf.Session</cite> for more
information on launching a graph and on sessions.</p>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a>python
v = tf.Variable([1, 2])
init = tf.global_variables_initializer()</p>
<dl class="simple">
<dt>with tf.Session() as sess:</dt><dd><p>sess.run(init)
# Usage passing the session explicitly.
v.load([2, 3], sess)
print(v.eval(sess)) # prints [2 3]
# Usage with the default session.  The ‘with’ block
# above makes ‘sess’ the default session.
v.load([3, 4], sess)
print(v.eval()) # prints [3 4]</p>
</dd>
</dl>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – New variable value</p></li>
<li><p><strong>session</strong> – The session to use to evaluate this variable. If
none, the default session is used.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – Session is not passed and no default session</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the object.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.numpy">
<code class="descname">numpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.op">
<code class="descname">op</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The op for this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.params">
<code class="descname">params</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.read_value">
<code class="descname">read_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.read_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an op which reads the value of this variable.</p>
<p>Should be used when there are multiple reads, or when it is desirable to
read the value only after some condition is true.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the read operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.register_cacher">
<code class="descname">register_cacher</code><span class="sig-paren">(</span><em>cacher: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]]</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.register_cacher" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <cite>cacher</cite> that caches values produces by this instance; a dependent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>)</strong> (<em>cacher</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.reset_cache">
<code class="descname">reset_cache</code><span class="sig-paren">(</span><em>reseter: zfit.util.cache.ZfitCachable</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.reset_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.reset_cache_self">
<code class="descname">reset_cache_self</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.reset_cache_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache of self and all dependent cachers.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.scatter_add">
<code class="descname">scatter_add</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.scatter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be added to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.scatter_nd_add">
<code class="descname">scatter_nd_add</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.scatter_nd_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse addition to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
add = ref.scatter_nd_add(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(add)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 13, 3, 14, 14, 6, 7, 20]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.scatter_nd_sub">
<code class="descname">scatter_nd_sub</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.scatter_nd_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse subtraction to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_sub(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, -9, 3, -6, -6, 6, 7, -4]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.scatter_nd_update">
<code class="descname">scatter_nd_update</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.scatter_nd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse assignment to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_update(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 11, 3, 10, 9, 6, 7, 12]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.scatter_sub">
<code class="descname">scatter_sub</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.scatter_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be subtracted from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.scatter_update">
<code class="descname">scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.set_shape">
<code class="descname">set_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.set_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.shape">
<code class="descname">shape</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.sparse_read">
<code class="descname">sparse_read</code><span class="sig-paren">(</span><em>indices</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.sparse_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the value of this variable sparsely, using <cite>gather</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a <cite>ResourceVariable</cite> to a <cite>VariableDef</cite> protocol buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><strong>RuntimeError</strong></a> – If run in EAGER mode.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>VariableDef</cite> protocol buffer, or <cite>None</cite> if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseComposedParameter.trainable">
<code class="descname">trainable</code><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseComposedParameter.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.BaseComposedParameter.value" title="Permalink to this definition">¶</a></dt>
<dd><p>A cached operation which reads the value of this variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.BaseParameter">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">BaseParameter</code><a class="reference internal" href="../_modules/zfit/core/parameter.html#BaseParameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.BaseParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="zfit.core.interfaces.html#zfit.core.interfaces.ZfitParameter" title="zfit.core.interfaces.ZfitParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.interfaces.ZfitParameter</span></code></a></p>
<dl class="attribute">
<dt id="zfit.core.parameter.BaseParameter.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.BaseParameter.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>DType</cite> of <cite>Tensor`s handled by this `model</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseParameter.floating">
<code class="descname">floating</code><a class="headerlink" href="#zfit.core.parameter.BaseParameter.floating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseParameter.get_dependents">
<code class="descname">get_dependents</code><span class="sig-paren">(</span><em>only_floating: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[zfit.core.parameter.Parameter]<a class="headerlink" href="#zfit.core.parameter.BaseParameter.get_dependents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseParameter.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>only_floating: bool = False, names: Union[str, List[str], None] = None</em><span class="sig-paren">)</span> &#x2192; List[zfit.core.interfaces.ZfitParameter]<a class="headerlink" href="#zfit.core.parameter.BaseParameter.get_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseParameter.independent">
<code class="descname">independent</code><a class="headerlink" href="#zfit.core.parameter.BaseParameter.independent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.BaseParameter.params">
<code class="descname">params</code><a class="headerlink" href="#zfit.core.parameter.BaseParameter.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.BaseParameter.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; tensorflow.python.framework.ops.Tensor<a class="headerlink" href="#zfit.core.parameter.BaseParameter.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.ComplexParameter">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">ComplexParameter</code><span class="sig-paren">(</span><em>name</em>, <em>value</em>, <em>dtype=tf.complex128</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComplexParameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComplexParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#zfit.core.parameter.ComposedParameter" title="zfit.core.parameter.ComposedParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.ComposedParameter</span></code></a></p>
<dl class="class">
<dt id="zfit.core.parameter.ComplexParameter.SaveSliceInfo">
<em class="property">class </em><code class="descname">SaveSliceInfo</code><span class="sig-paren">(</span><em>full_name=None</em>, <em>full_shape=None</em>, <em>var_offset=None</em>, <em>var_shape=None</em>, <em>save_slice_info_def=None</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.SaveSliceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Information on how to save this Variable as a slice.</p>
<p>Provides internal support for saving variables as slices of a larger
variable.  This API is not public and is subject to change.</p>
<p>Available properties:</p>
<ul class="simple">
<li><p>full_name</p></li>
<li><p>full_shape</p></li>
<li><p>var_offset</p></li>
<li><p>var_shape</p></li>
</ul>
<p>Create a <cite>SaveSliceInfo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_name</strong> – Name of the full variable of which this <cite>Variable</cite> is a
slice.</p></li>
<li><p><strong>full_shape</strong> – Shape of the full variable, as a list of int.</p></li>
<li><p><strong>var_offset</strong> – Offset of this <cite>Variable</cite> into the full variable, as a
list of int.</p></li>
<li><p><strong>var_shape</strong> – Shape of this <cite>Variable</cite>, as a list of int.</p></li>
<li><p><strong>save_slice_info_def</strong> – <cite>SaveSliceInfoDef</cite> protocol buffer. If not <cite>None</cite>,
recreates the SaveSliceInfo object its contents.
<cite>save_slice_info_def</cite> and other arguments are mutually
exclusive.</p></li>
<li><p><strong>import_scope</strong> – Optional <cite>string</cite>. Name scope to add. Only used
when initializing from protocol buffer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.SaveSliceInfo.spec">
<code class="descname">spec</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.SaveSliceInfo.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the spec string used for saving.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.SaveSliceInfo.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.SaveSliceInfo.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SaveSliceInfoDef() proto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>SaveSliceInfoDef</cite> protocol buffer, or None if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy method to prevent iteration. Do not call.</p>
<p>NOTE(mrry): If we register __getitem__ as an overloaded operator,
Python will valiantly attempt to iterate over the variable’s Tensor from 0
to infinity.  Declaring this method prevents this unintended behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – when invoked.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.add_cache_dependents">
<code class="descname">add_cache_dependents</code><span class="sig-paren">(</span><em>cache_dependents: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]], allow_non_cachable: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.add_cache_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dependents that render the cache invalid if they change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cache_dependents</strong> (<a class="reference internal" href="zfit.util.cache.html#zfit.util.cache.ZfitCachable" title="zfit.util.cache.ZfitCachable"><em>ZfitCachable</em></a>) – </p></li>
<li><p><strong>allow_non_cachable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, allow <cite>cache_dependents</cite> to be non-cachables.
If <cite>False</cite>, any <cite>cache_dependents</cite> that is not a <cite>ZfitCachable</cite> will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – if one of the <cite>cache_dependents</cite> is not a <cite>ZfitCachable</cite> _and_ <cite>allow_non_cachable</cite>
    if <cite>False</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.arg">
<code class="descname">arg</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=False</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a new value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – A <cite>Tensor</cite>. The new value for this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the assignment.</p></li>
<li><p><strong>name</strong> – The name to use for the assignment.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.assign_add">
<code class="descname">assign_add</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.assign_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to add to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.assign_sub">
<code class="descname">assign_sub</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.assign_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts a value from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to subtract from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.batch_scatter_update">
<code class="descname">batch_scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.batch_scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable batch-wise.</p>
<p>Analogous to <cite>batch_gather</cite>. This assumes that this variable and the
sparse_delta IndexedSlices have a series of leading dimensions that are the
same for all of them, and the updates are performed on the last dimension of
indices. In other words, the dimensions should be the following:</p>
<p><cite>num_prefix_dims = sparse_delta.indices.ndims - 1</cite>
<cite>batch_dim = num_prefix_dims + 1</cite>
<a href="#id37"><span class="problematic" id="id38">`</span></a>sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[</p>
<blockquote>
<div><p>batch_dim:]`</p>
</div></blockquote>
<p>where</p>
<p><cite>sparse_delta.updates.shape[:num_prefix_dims]</cite>
<cite>== sparse_delta.indices.shape[:num_prefix_dims]</cite>
<cite>== var.shape[:num_prefix_dims]</cite></p>
<p>And the operation performed can be expressed as:</p>
<dl class="simple">
<dt><a href="#id39"><span class="problematic" id="id40">`</span></a>var[i_1, …, i_n,</dt><dd><dl class="simple">
<dt>sparse_delta.indices[i_1, …, i_n, j]] = sparse_delta.updates[</dt><dd><p>i_1, …, i_n, j]`</p>
</dd>
</dl>
</dd>
</dl>
<p>When sparse_delta.indices is a 1D tensor, this operation is equivalent to
<cite>scatter_update</cite>.</p>
<p>To avoid this operation one can looping over the first <cite>ndims</cite> of the
variable and using <cite>scatter_update</cite> on the subtensors that result of slicing
the first dimension. This is a valid option for <cite>ndims = 1</cite>, but less
efficient than this implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.conj">
<code class="descname">conj</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.conj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.constraint">
<code class="descname">constraint</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the constraint function associated with this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint function that was passed to the variable constructor.
Can be <cite>None</cite> if no constraint was passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep: bool = False</em>, <em>name: str = None</em>, <em>**overwrite_params</em><span class="sig-paren">)</span> &#x2192; zfit.core.interfaces.ZfitObject<a class="headerlink" href="#zfit.core.parameter.ComplexParameter.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.count_up_to">
<code class="descname">count_up_to</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.count_up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments this variable until it reaches <cite>limit</cite>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Prefer Dataset.range instead.</p>
<p>When that Op is run it tries to increment the variable by <cite>1</cite>. If
incrementing the variable would bring it above <cite>limit</cite> then the Op raises
the exception <cite>OutOfRangeError</cite>.</p>
<p>If no error is raised, the Op outputs the value of the variable before
the increment.</p>
<p>This is essentially a shortcut for <cite>count_up_to(self, limit)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>limit</strong> – value at which incrementing the variable raises an error.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the variable value before the increment. If no
other Op modifies this variable, the values produced will all be
distinct.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.create">
<code class="descname">create</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.create" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.device">
<code class="descname">device</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The device this variable is on.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the object</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and returns the value of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.floating">
<code class="descname">floating</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.floating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.ComplexParameter.from_cartesian">
<em class="property">static </em><code class="descname">from_cartesian</code><span class="sig-paren">(</span><em>name</em>, <em>real</em>, <em>imag</em>, <em>dtype=tf.complex128</em>, <em>floating=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComplexParameter.from_cartesian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.from_cartesian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.ComplexParameter.from_polar">
<em class="property">static </em><code class="descname">from_polar</code><span class="sig-paren">(</span><em>name</em>, <em>mod</em>, <em>arg</em>, <em>dtype=tf.complex128</em>, <em>floating=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComplexParameter.from_polar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.from_polar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.ComplexParameter.from_proto">
<em class="property">static </em><code class="descname">from_proto</code><span class="sig-paren">(</span><em>variable_def</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.from_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>Variable</cite> object created from <cite>variable_def</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.get_dependents">
<code class="descname">get_dependents</code><span class="sig-paren">(</span><em>only_floating: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[zfit.core.parameter.Parameter]<a class="headerlink" href="#zfit.core.parameter.ComplexParameter.get_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of all independent <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> that this object depends on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>only_floating</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, only return floating <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>only_floating: bool = False, names: Union[str, List[str], None] = None</em><span class="sig-paren">)</span> &#x2192; List[zfit.core.interfaces.ZfitParameter]<a class="headerlink" href="#zfit.core.parameter.ComplexParameter.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters. If it is empty, automatically return all floating variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>)</strong> (<em>names</em>) – If True, return only the floating parameters.</p></li>
<li><p><strong>(</strong><strong>)</strong> – The names of the parameters to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(<cite>ZfitParameters</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of Variable.shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.graph">
<code class="descname">graph</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Graph</cite> of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.handle">
<code class="descname">handle</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle by which this variable can be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.imag">
<code class="descname">imag</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.imag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.independent">
<code class="descname">independent</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.independent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.initial_value">
<code class="descname">initial_value</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Tensor used as the initial value for the variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.initialized_value">
<code class="descname">initialized_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.initialized_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the initialized variable.</p>
<p>You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">'v'</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">random</span> <span class="pre">tensor.</span>
<span class="pre">v</span> <span class="pre">=</span> <span class="pre">tf.Variable(tf.truncated_normal([10,</span> <span class="pre">40]))</span>
<span class="pre">#</span> <span class="pre">Use</span> <span class="pre">`initialized_value`</span> <span class="pre">to</span> <span class="pre">guarantee</span> <span class="pre">that</span> <span class="pre">`v`</span> <span class="pre">has</span> <span class="pre">been</span>
<span class="pre">#</span> <span class="pre">initialized</span> <span class="pre">before</span> <span class="pre">its</span> <span class="pre">value</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">initialize</span> <span class="pre">`w`.</span>
<span class="pre">#</span> <span class="pre">The</span> <span class="pre">random</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">picked</span> <span class="pre">only</span> <span class="pre">once.</span>
<span class="pre">w</span> <span class="pre">=</span> <span class="pre">tf.Variable(v.initialized_value()</span> <span class="pre">*</span> <span class="pre">2.0)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Tensor</cite> holding the value of this variable after its initializer
has run.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.is_initialized">
<code class="descname">is_initialized</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.is_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a resource variable has been initialized.</p>
<p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – A name for the operation (optional).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> of type <cite>bool</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>value</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load new value into this variable.</p>
<p>Writes new value to variable’s memory. Doesn’t add ops to the graph.</p>
<p>This convenience method requires a session where the graph
containing this variable has been launched. If no session is
passed, the default session is used.  See <cite>tf.Session</cite> for more
information on launching a graph and on sessions.</p>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a>python
v = tf.Variable([1, 2])
init = tf.global_variables_initializer()</p>
<dl class="simple">
<dt>with tf.Session() as sess:</dt><dd><p>sess.run(init)
# Usage passing the session explicitly.
v.load([2, 3], sess)
print(v.eval(sess)) # prints [2 3]
# Usage with the default session.  The ‘with’ block
# above makes ‘sess’ the default session.
v.load([3, 4], sess)
print(v.eval()) # prints [3 4]</p>
</dd>
</dl>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – New variable value</p></li>
<li><p><strong>session</strong> – The session to use to evaluate this variable. If
none, the default session is used.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – Session is not passed and no default session</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.mod">
<code class="descname">mod</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.mod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the object.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.numpy">
<code class="descname">numpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.op">
<code class="descname">op</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The op for this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.params">
<code class="descname">params</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.read_value">
<code class="descname">read_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.read_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an op which reads the value of this variable.</p>
<p>Should be used when there are multiple reads, or when it is desirable to
read the value only after some condition is true.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the read operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.real">
<code class="descname">real</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.register_cacher">
<code class="descname">register_cacher</code><span class="sig-paren">(</span><em>cacher: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]]</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.register_cacher" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <cite>cacher</cite> that caches values produces by this instance; a dependent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>)</strong> (<em>cacher</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.reset_cache">
<code class="descname">reset_cache</code><span class="sig-paren">(</span><em>reseter: zfit.util.cache.ZfitCachable</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.reset_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.reset_cache_self">
<code class="descname">reset_cache_self</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.reset_cache_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache of self and all dependent cachers.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.scatter_add">
<code class="descname">scatter_add</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.scatter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be added to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.scatter_nd_add">
<code class="descname">scatter_nd_add</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.scatter_nd_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse addition to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id49"><span class="problematic" id="id50">``</span></a><a href="#id51"><span class="problematic" id="id52">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
add = ref.scatter_nd_add(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(add)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id53"><span class="problematic" id="id54">``</span></a><a href="#id55"><span class="problematic" id="id56">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 13, 3, 14, 14, 6, 7, 20]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.scatter_nd_sub">
<code class="descname">scatter_nd_sub</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.scatter_nd_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse subtraction to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id57"><span class="problematic" id="id58">``</span></a><a href="#id59"><span class="problematic" id="id60">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_sub(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id61"><span class="problematic" id="id62">``</span></a><a href="#id63"><span class="problematic" id="id64">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, -9, 3, -6, -6, 6, 7, -4]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.scatter_nd_update">
<code class="descname">scatter_nd_update</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.scatter_nd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse assignment to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_update(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 11, 3, 10, 9, 6, 7, 12]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.scatter_sub">
<code class="descname">scatter_sub</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.scatter_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be subtracted from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.scatter_update">
<code class="descname">scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.set_shape">
<code class="descname">set_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.set_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.shape">
<code class="descname">shape</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.sparse_read">
<code class="descname">sparse_read</code><span class="sig-paren">(</span><em>indices</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.sparse_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the value of this variable sparsely, using <cite>gather</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a <cite>ResourceVariable</cite> to a <cite>VariableDef</cite> protocol buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><strong>RuntimeError</strong></a> – If run in EAGER mode.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>VariableDef</cite> protocol buffer, or <cite>None</cite> if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComplexParameter.trainable">
<code class="descname">trainable</code><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComplexParameter.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComplexParameter.value" title="Permalink to this definition">¶</a></dt>
<dd><p>A cached operation which reads the value of this variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.ComposedParameter">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">ComposedParameter</code><span class="sig-paren">(</span><em>name</em>, <em>tensor</em>, <em>dtype=tf.float64</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedParameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#zfit.core.parameter.BaseComposedParameter" title="zfit.core.parameter.BaseComposedParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.BaseComposedParameter</span></code></a></p>
<dl class="class">
<dt id="zfit.core.parameter.ComposedParameter.SaveSliceInfo">
<em class="property">class </em><code class="descname">SaveSliceInfo</code><span class="sig-paren">(</span><em>full_name=None</em>, <em>full_shape=None</em>, <em>var_offset=None</em>, <em>var_shape=None</em>, <em>save_slice_info_def=None</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.SaveSliceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Information on how to save this Variable as a slice.</p>
<p>Provides internal support for saving variables as slices of a larger
variable.  This API is not public and is subject to change.</p>
<p>Available properties:</p>
<ul class="simple">
<li><p>full_name</p></li>
<li><p>full_shape</p></li>
<li><p>var_offset</p></li>
<li><p>var_shape</p></li>
</ul>
<p>Create a <cite>SaveSliceInfo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_name</strong> – Name of the full variable of which this <cite>Variable</cite> is a
slice.</p></li>
<li><p><strong>full_shape</strong> – Shape of the full variable, as a list of int.</p></li>
<li><p><strong>var_offset</strong> – Offset of this <cite>Variable</cite> into the full variable, as a
list of int.</p></li>
<li><p><strong>var_shape</strong> – Shape of this <cite>Variable</cite>, as a list of int.</p></li>
<li><p><strong>save_slice_info_def</strong> – <cite>SaveSliceInfoDef</cite> protocol buffer. If not <cite>None</cite>,
recreates the SaveSliceInfo object its contents.
<cite>save_slice_info_def</cite> and other arguments are mutually
exclusive.</p></li>
<li><p><strong>import_scope</strong> – Optional <cite>string</cite>. Name scope to add. Only used
when initializing from protocol buffer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.SaveSliceInfo.spec">
<code class="descname">spec</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.SaveSliceInfo.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the spec string used for saving.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.SaveSliceInfo.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.SaveSliceInfo.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SaveSliceInfoDef() proto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>SaveSliceInfoDef</cite> protocol buffer, or None if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy method to prevent iteration. Do not call.</p>
<p>NOTE(mrry): If we register __getitem__ as an overloaded operator,
Python will valiantly attempt to iterate over the variable’s Tensor from 0
to infinity.  Declaring this method prevents this unintended behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – when invoked.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.add_cache_dependents">
<code class="descname">add_cache_dependents</code><span class="sig-paren">(</span><em>cache_dependents: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]], allow_non_cachable: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.add_cache_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dependents that render the cache invalid if they change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cache_dependents</strong> (<a class="reference internal" href="zfit.util.cache.html#zfit.util.cache.ZfitCachable" title="zfit.util.cache.ZfitCachable"><em>ZfitCachable</em></a>) – </p></li>
<li><p><strong>allow_non_cachable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, allow <cite>cache_dependents</cite> to be non-cachables.
If <cite>False</cite>, any <cite>cache_dependents</cite> that is not a <cite>ZfitCachable</cite> will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – if one of the <cite>cache_dependents</cite> is not a <cite>ZfitCachable</cite> _and_ <cite>allow_non_cachable</cite>
    if <cite>False</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=False</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a new value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – A <cite>Tensor</cite>. The new value for this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the assignment.</p></li>
<li><p><strong>name</strong> – The name to use for the assignment.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.assign_add">
<code class="descname">assign_add</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.assign_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to add to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.assign_sub">
<code class="descname">assign_sub</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.assign_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts a value from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to subtract from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.batch_scatter_update">
<code class="descname">batch_scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.batch_scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable batch-wise.</p>
<p>Analogous to <cite>batch_gather</cite>. This assumes that this variable and the
sparse_delta IndexedSlices have a series of leading dimensions that are the
same for all of them, and the updates are performed on the last dimension of
indices. In other words, the dimensions should be the following:</p>
<p><cite>num_prefix_dims = sparse_delta.indices.ndims - 1</cite>
<cite>batch_dim = num_prefix_dims + 1</cite>
<a href="#id73"><span class="problematic" id="id74">`</span></a>sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[</p>
<blockquote>
<div><p>batch_dim:]`</p>
</div></blockquote>
<p>where</p>
<p><cite>sparse_delta.updates.shape[:num_prefix_dims]</cite>
<cite>== sparse_delta.indices.shape[:num_prefix_dims]</cite>
<cite>== var.shape[:num_prefix_dims]</cite></p>
<p>And the operation performed can be expressed as:</p>
<dl class="simple">
<dt><a href="#id75"><span class="problematic" id="id76">`</span></a>var[i_1, …, i_n,</dt><dd><dl class="simple">
<dt>sparse_delta.indices[i_1, …, i_n, j]] = sparse_delta.updates[</dt><dd><p>i_1, …, i_n, j]`</p>
</dd>
</dl>
</dd>
</dl>
<p>When sparse_delta.indices is a 1D tensor, this operation is equivalent to
<cite>scatter_update</cite>.</p>
<p>To avoid this operation one can looping over the first <cite>ndims</cite> of the
variable and using <cite>scatter_update</cite> on the subtensors that result of slicing
the first dimension. This is a valid option for <cite>ndims = 1</cite>, but less
efficient than this implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.constraint">
<code class="descname">constraint</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the constraint function associated with this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint function that was passed to the variable constructor.
Can be <cite>None</cite> if no constraint was passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep: bool = False</em>, <em>name: str = None</em>, <em>**overwrite_params</em><span class="sig-paren">)</span> &#x2192; zfit.core.interfaces.ZfitObject<a class="headerlink" href="#zfit.core.parameter.ComposedParameter.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.count_up_to">
<code class="descname">count_up_to</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.count_up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments this variable until it reaches <cite>limit</cite>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Prefer Dataset.range instead.</p>
<p>When that Op is run it tries to increment the variable by <cite>1</cite>. If
incrementing the variable would bring it above <cite>limit</cite> then the Op raises
the exception <cite>OutOfRangeError</cite>.</p>
<p>If no error is raised, the Op outputs the value of the variable before
the increment.</p>
<p>This is essentially a shortcut for <cite>count_up_to(self, limit)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>limit</strong> – value at which incrementing the variable raises an error.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the variable value before the increment. If no
other Op modifies this variable, the values produced will all be
distinct.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.create">
<code class="descname">create</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.create" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.device">
<code class="descname">device</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The device this variable is on.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the object</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and returns the value of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.floating">
<code class="descname">floating</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.floating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.ComposedParameter.from_proto">
<em class="property">static </em><code class="descname">from_proto</code><span class="sig-paren">(</span><em>variable_def</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.from_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>Variable</cite> object created from <cite>variable_def</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.get_dependents">
<code class="descname">get_dependents</code><span class="sig-paren">(</span><em>only_floating: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[zfit.core.parameter.Parameter]<a class="headerlink" href="#zfit.core.parameter.ComposedParameter.get_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of all independent <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> that this object depends on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>only_floating</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, only return floating <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>only_floating: bool = False, names: Union[str, List[str], None] = None</em><span class="sig-paren">)</span> &#x2192; List[zfit.core.interfaces.ZfitParameter]<a class="headerlink" href="#zfit.core.parameter.ComposedParameter.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters. If it is empty, automatically return all floating variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>)</strong> (<em>names</em>) – If True, return only the floating parameters.</p></li>
<li><p><strong>(</strong><strong>)</strong> – The names of the parameters to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(<cite>ZfitParameters</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of Variable.shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.graph">
<code class="descname">graph</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Graph</cite> of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.handle">
<code class="descname">handle</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle by which this variable can be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.independent">
<code class="descname">independent</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.independent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.initial_value">
<code class="descname">initial_value</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Tensor used as the initial value for the variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.initialized_value">
<code class="descname">initialized_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.initialized_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the initialized variable.</p>
<p>You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">'v'</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">random</span> <span class="pre">tensor.</span>
<span class="pre">v</span> <span class="pre">=</span> <span class="pre">tf.Variable(tf.truncated_normal([10,</span> <span class="pre">40]))</span>
<span class="pre">#</span> <span class="pre">Use</span> <span class="pre">`initialized_value`</span> <span class="pre">to</span> <span class="pre">guarantee</span> <span class="pre">that</span> <span class="pre">`v`</span> <span class="pre">has</span> <span class="pre">been</span>
<span class="pre">#</span> <span class="pre">initialized</span> <span class="pre">before</span> <span class="pre">its</span> <span class="pre">value</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">initialize</span> <span class="pre">`w`.</span>
<span class="pre">#</span> <span class="pre">The</span> <span class="pre">random</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">picked</span> <span class="pre">only</span> <span class="pre">once.</span>
<span class="pre">w</span> <span class="pre">=</span> <span class="pre">tf.Variable(v.initialized_value()</span> <span class="pre">*</span> <span class="pre">2.0)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Tensor</cite> holding the value of this variable after its initializer
has run.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.is_initialized">
<code class="descname">is_initialized</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.is_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a resource variable has been initialized.</p>
<p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – A name for the operation (optional).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> of type <cite>bool</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>value</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load new value into this variable.</p>
<p>Writes new value to variable’s memory. Doesn’t add ops to the graph.</p>
<p>This convenience method requires a session where the graph
containing this variable has been launched. If no session is
passed, the default session is used.  See <cite>tf.Session</cite> for more
information on launching a graph and on sessions.</p>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a>python
v = tf.Variable([1, 2])
init = tf.global_variables_initializer()</p>
<dl class="simple">
<dt>with tf.Session() as sess:</dt><dd><p>sess.run(init)
# Usage passing the session explicitly.
v.load([2, 3], sess)
print(v.eval(sess)) # prints [2 3]
# Usage with the default session.  The ‘with’ block
# above makes ‘sess’ the default session.
v.load([3, 4], sess)
print(v.eval()) # prints [3 4]</p>
</dd>
</dl>
<p><a href="#id81"><span class="problematic" id="id82">``</span></a><a href="#id83"><span class="problematic" id="id84">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – New variable value</p></li>
<li><p><strong>session</strong> – The session to use to evaluate this variable. If
none, the default session is used.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – Session is not passed and no default session</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the object.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.numpy">
<code class="descname">numpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.op">
<code class="descname">op</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The op for this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.params">
<code class="descname">params</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.read_value">
<code class="descname">read_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.read_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an op which reads the value of this variable.</p>
<p>Should be used when there are multiple reads, or when it is desirable to
read the value only after some condition is true.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the read operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.register_cacher">
<code class="descname">register_cacher</code><span class="sig-paren">(</span><em>cacher: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]]</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.register_cacher" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <cite>cacher</cite> that caches values produces by this instance; a dependent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>)</strong> (<em>cacher</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.reset_cache">
<code class="descname">reset_cache</code><span class="sig-paren">(</span><em>reseter: zfit.util.cache.ZfitCachable</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.reset_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.reset_cache_self">
<code class="descname">reset_cache_self</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.reset_cache_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache of self and all dependent cachers.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.scatter_add">
<code class="descname">scatter_add</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.scatter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be added to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.scatter_nd_add">
<code class="descname">scatter_nd_add</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.scatter_nd_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse addition to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id85"><span class="problematic" id="id86">``</span></a><a href="#id87"><span class="problematic" id="id88">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
add = ref.scatter_nd_add(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(add)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id89"><span class="problematic" id="id90">``</span></a><a href="#id91"><span class="problematic" id="id92">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 13, 3, 14, 14, 6, 7, 20]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.scatter_nd_sub">
<code class="descname">scatter_nd_sub</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.scatter_nd_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse subtraction to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id93"><span class="problematic" id="id94">``</span></a><a href="#id95"><span class="problematic" id="id96">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_sub(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id97"><span class="problematic" id="id98">``</span></a><a href="#id99"><span class="problematic" id="id100">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, -9, 3, -6, -6, 6, 7, -4]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.scatter_nd_update">
<code class="descname">scatter_nd_update</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.scatter_nd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse assignment to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_update(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 11, 3, 10, 9, 6, 7, 12]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.scatter_sub">
<code class="descname">scatter_sub</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.scatter_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be subtracted from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.scatter_update">
<code class="descname">scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.set_shape">
<code class="descname">set_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.set_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.shape">
<code class="descname">shape</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.sparse_read">
<code class="descname">sparse_read</code><span class="sig-paren">(</span><em>indices</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.sparse_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the value of this variable sparsely, using <cite>gather</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a <cite>ResourceVariable</cite> to a <cite>VariableDef</cite> protocol buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><strong>RuntimeError</strong></a> – If run in EAGER mode.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>VariableDef</cite> protocol buffer, or <cite>None</cite> if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedParameter.trainable">
<code class="descname">trainable</code><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedParameter.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedParameter.value" title="Permalink to this definition">¶</a></dt>
<dd><p>A cached operation which reads the value of this variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.ComposedResourceVariable">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">ComposedResourceVariable</code><span class="sig-paren">(</span><em>name</em>, <em>initial_value</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedResourceVariable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.resource_variable_ops.ResourceVariable</span></code></p>
<dl class="class">
<dt id="zfit.core.parameter.ComposedResourceVariable.SaveSliceInfo">
<em class="property">class </em><code class="descname">SaveSliceInfo</code><span class="sig-paren">(</span><em>full_name=None</em>, <em>full_shape=None</em>, <em>var_offset=None</em>, <em>var_shape=None</em>, <em>save_slice_info_def=None</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.SaveSliceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Information on how to save this Variable as a slice.</p>
<p>Provides internal support for saving variables as slices of a larger
variable.  This API is not public and is subject to change.</p>
<p>Available properties:</p>
<ul class="simple">
<li><p>full_name</p></li>
<li><p>full_shape</p></li>
<li><p>var_offset</p></li>
<li><p>var_shape</p></li>
</ul>
<p>Create a <cite>SaveSliceInfo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_name</strong> – Name of the full variable of which this <cite>Variable</cite> is a
slice.</p></li>
<li><p><strong>full_shape</strong> – Shape of the full variable, as a list of int.</p></li>
<li><p><strong>var_offset</strong> – Offset of this <cite>Variable</cite> into the full variable, as a
list of int.</p></li>
<li><p><strong>var_shape</strong> – Shape of this <cite>Variable</cite>, as a list of int.</p></li>
<li><p><strong>save_slice_info_def</strong> – <cite>SaveSliceInfoDef</cite> protocol buffer. If not <cite>None</cite>,
recreates the SaveSliceInfo object its contents.
<cite>save_slice_info_def</cite> and other arguments are mutually
exclusive.</p></li>
<li><p><strong>import_scope</strong> – Optional <cite>string</cite>. Name scope to add. Only used
when initializing from protocol buffer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.SaveSliceInfo.spec">
<code class="descname">spec</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.SaveSliceInfo.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the spec string used for saving.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.SaveSliceInfo.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.SaveSliceInfo.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SaveSliceInfoDef() proto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>SaveSliceInfoDef</cite> protocol buffer, or None if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy method to prevent iteration. Do not call.</p>
<p>NOTE(mrry): If we register __getitem__ as an overloaded operator,
Python will valiantly attempt to iterate over the variable’s Tensor from 0
to infinity.  Declaring this method prevents this unintended behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – when invoked.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a new value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – A <cite>Tensor</cite>. The new value for this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the assignment.</p></li>
<li><p><strong>name</strong> – The name to use for the assignment.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.assign_add">
<code class="descname">assign_add</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.assign_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to add to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.assign_sub">
<code class="descname">assign_sub</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.assign_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts a value from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to subtract from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.batch_scatter_update">
<code class="descname">batch_scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.batch_scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable batch-wise.</p>
<p>Analogous to <cite>batch_gather</cite>. This assumes that this variable and the
sparse_delta IndexedSlices have a series of leading dimensions that are the
same for all of them, and the updates are performed on the last dimension of
indices. In other words, the dimensions should be the following:</p>
<p><cite>num_prefix_dims = sparse_delta.indices.ndims - 1</cite>
<cite>batch_dim = num_prefix_dims + 1</cite>
<a href="#id109"><span class="problematic" id="id110">`</span></a>sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[</p>
<blockquote>
<div><p>batch_dim:]`</p>
</div></blockquote>
<p>where</p>
<p><cite>sparse_delta.updates.shape[:num_prefix_dims]</cite>
<cite>== sparse_delta.indices.shape[:num_prefix_dims]</cite>
<cite>== var.shape[:num_prefix_dims]</cite></p>
<p>And the operation performed can be expressed as:</p>
<dl class="simple">
<dt><a href="#id111"><span class="problematic" id="id112">`</span></a>var[i_1, …, i_n,</dt><dd><dl class="simple">
<dt>sparse_delta.indices[i_1, …, i_n, j]] = sparse_delta.updates[</dt><dd><p>i_1, …, i_n, j]`</p>
</dd>
</dl>
</dd>
</dl>
<p>When sparse_delta.indices is a 1D tensor, this operation is equivalent to
<cite>scatter_update</cite>.</p>
<p>To avoid this operation one can looping over the first <cite>ndims</cite> of the
variable and using <cite>scatter_update</cite> on the subtensors that result of slicing
the first dimension. This is a valid option for <cite>ndims = 1</cite>, but less
efficient than this implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.constraint">
<code class="descname">constraint</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the constraint function associated with this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint function that was passed to the variable constructor.
Can be <cite>None</cite> if no constraint was passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.count_up_to">
<code class="descname">count_up_to</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.count_up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments this variable until it reaches <cite>limit</cite>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Prefer Dataset.range instead.</p>
<p>When that Op is run it tries to increment the variable by <cite>1</cite>. If
incrementing the variable would bring it above <cite>limit</cite> then the Op raises
the exception <cite>OutOfRangeError</cite>.</p>
<p>If no error is raised, the Op outputs the value of the variable before
the increment.</p>
<p>This is essentially a shortcut for <cite>count_up_to(self, limit)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>limit</strong> – value at which incrementing the variable raises an error.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the variable value before the increment. If no
other Op modifies this variable, the values produced will all be
distinct.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.create">
<code class="descname">create</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.create" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.device">
<code class="descname">device</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The device this variable is on.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and returns the value of this variable.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.ComposedResourceVariable.from_proto">
<em class="property">static </em><code class="descname">from_proto</code><span class="sig-paren">(</span><em>variable_def</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.from_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>Variable</cite> object created from <cite>variable_def</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of Variable.shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.graph">
<code class="descname">graph</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Graph</cite> of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.handle">
<code class="descname">handle</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle by which this variable can be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.initial_value">
<code class="descname">initial_value</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Tensor used as the initial value for the variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.initialized_value">
<code class="descname">initialized_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.initialized_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the initialized variable.</p>
<p>You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">'v'</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">random</span> <span class="pre">tensor.</span>
<span class="pre">v</span> <span class="pre">=</span> <span class="pre">tf.Variable(tf.truncated_normal([10,</span> <span class="pre">40]))</span>
<span class="pre">#</span> <span class="pre">Use</span> <span class="pre">`initialized_value`</span> <span class="pre">to</span> <span class="pre">guarantee</span> <span class="pre">that</span> <span class="pre">`v`</span> <span class="pre">has</span> <span class="pre">been</span>
<span class="pre">#</span> <span class="pre">initialized</span> <span class="pre">before</span> <span class="pre">its</span> <span class="pre">value</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">initialize</span> <span class="pre">`w`.</span>
<span class="pre">#</span> <span class="pre">The</span> <span class="pre">random</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">picked</span> <span class="pre">only</span> <span class="pre">once.</span>
<span class="pre">w</span> <span class="pre">=</span> <span class="pre">tf.Variable(v.initialized_value()</span> <span class="pre">*</span> <span class="pre">2.0)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Tensor</cite> holding the value of this variable after its initializer
has run.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.is_initialized">
<code class="descname">is_initialized</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.is_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a resource variable has been initialized.</p>
<p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – A name for the operation (optional).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> of type <cite>bool</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>value</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load new value into this variable.</p>
<p>Writes new value to variable’s memory. Doesn’t add ops to the graph.</p>
<p>This convenience method requires a session where the graph
containing this variable has been launched. If no session is
passed, the default session is used.  See <cite>tf.Session</cite> for more
information on launching a graph and on sessions.</p>
<p><a href="#id113"><span class="problematic" id="id114">``</span></a><a href="#id115"><span class="problematic" id="id116">`</span></a>python
v = tf.Variable([1, 2])
init = tf.global_variables_initializer()</p>
<dl class="simple">
<dt>with tf.Session() as sess:</dt><dd><p>sess.run(init)
# Usage passing the session explicitly.
v.load([2, 3], sess)
print(v.eval(sess)) # prints [2 3]
# Usage with the default session.  The ‘with’ block
# above makes ‘sess’ the default session.
v.load([3, 4], sess)
print(v.eval()) # prints [3 4]</p>
</dd>
</dl>
<p><a href="#id117"><span class="problematic" id="id118">``</span></a><a href="#id119"><span class="problematic" id="id120">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – New variable value</p></li>
<li><p><strong>session</strong> – The session to use to evaluate this variable. If
none, the default session is used.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – Session is not passed and no default session</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the handle for this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.numpy">
<code class="descname">numpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.op">
<code class="descname">op</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The op for this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.read_value">
<code class="descname">read_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedResourceVariable.read_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.read_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an op which reads the value of this variable.</p>
<p>Should be used when there are multiple reads, or when it is desirable to
read the value only after some condition is true.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the read operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.scatter_add">
<code class="descname">scatter_add</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.scatter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be added to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.scatter_nd_add">
<code class="descname">scatter_nd_add</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.scatter_nd_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse addition to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id121"><span class="problematic" id="id122">``</span></a><a href="#id123"><span class="problematic" id="id124">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
add = ref.scatter_nd_add(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(add)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id125"><span class="problematic" id="id126">``</span></a><a href="#id127"><span class="problematic" id="id128">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 13, 3, 14, 14, 6, 7, 20]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.scatter_nd_sub">
<code class="descname">scatter_nd_sub</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.scatter_nd_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse subtraction to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id129"><span class="problematic" id="id130">``</span></a><a href="#id131"><span class="problematic" id="id132">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_sub(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id133"><span class="problematic" id="id134">``</span></a><a href="#id135"><span class="problematic" id="id136">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, -9, 3, -6, -6, 6, 7, -4]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.scatter_nd_update">
<code class="descname">scatter_nd_update</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.scatter_nd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse assignment to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id137"><span class="problematic" id="id138">``</span></a><a href="#id139"><span class="problematic" id="id140">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_update(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 11, 3, 10, 9, 6, 7, 12]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.scatter_sub">
<code class="descname">scatter_sub</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.scatter_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be subtracted from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.scatter_update">
<code class="descname">scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.set_shape">
<code class="descname">set_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.set_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.shape">
<code class="descname">shape</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.sparse_read">
<code class="descname">sparse_read</code><span class="sig-paren">(</span><em>indices</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.sparse_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the value of this variable sparsely, using <cite>gather</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a <cite>ResourceVariable</cite> to a <cite>VariableDef</cite> protocol buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><strong>RuntimeError</strong></a> – If run in EAGER mode.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>VariableDef</cite> protocol buffer, or <cite>None</cite> if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedResourceVariable.trainable">
<code class="descname">trainable</code><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedResourceVariable.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedResourceVariable.value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedResourceVariable.value" title="Permalink to this definition">¶</a></dt>
<dd><p>A cached operation which reads the value of this variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.ComposedVariable">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">ComposedVariable</code><span class="sig-paren">(</span><em>name: str</em>, <em>initial_value: tensorflow.python.framework.ops.Tensor</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedVariable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.resource_variable_ops.ResourceVariable</span></code></p>
<dl class="class">
<dt id="zfit.core.parameter.ComposedVariable.SaveSliceInfo">
<em class="property">class </em><code class="descname">SaveSliceInfo</code><span class="sig-paren">(</span><em>full_name=None</em>, <em>full_shape=None</em>, <em>var_offset=None</em>, <em>var_shape=None</em>, <em>save_slice_info_def=None</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.SaveSliceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Information on how to save this Variable as a slice.</p>
<p>Provides internal support for saving variables as slices of a larger
variable.  This API is not public and is subject to change.</p>
<p>Available properties:</p>
<ul class="simple">
<li><p>full_name</p></li>
<li><p>full_shape</p></li>
<li><p>var_offset</p></li>
<li><p>var_shape</p></li>
</ul>
<p>Create a <cite>SaveSliceInfo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_name</strong> – Name of the full variable of which this <cite>Variable</cite> is a
slice.</p></li>
<li><p><strong>full_shape</strong> – Shape of the full variable, as a list of int.</p></li>
<li><p><strong>var_offset</strong> – Offset of this <cite>Variable</cite> into the full variable, as a
list of int.</p></li>
<li><p><strong>var_shape</strong> – Shape of this <cite>Variable</cite>, as a list of int.</p></li>
<li><p><strong>save_slice_info_def</strong> – <cite>SaveSliceInfoDef</cite> protocol buffer. If not <cite>None</cite>,
recreates the SaveSliceInfo object its contents.
<cite>save_slice_info_def</cite> and other arguments are mutually
exclusive.</p></li>
<li><p><strong>import_scope</strong> – Optional <cite>string</cite>. Name scope to add. Only used
when initializing from protocol buffer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.SaveSliceInfo.spec">
<code class="descname">spec</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.SaveSliceInfo.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the spec string used for saving.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.SaveSliceInfo.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.SaveSliceInfo.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SaveSliceInfoDef() proto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>SaveSliceInfoDef</cite> protocol buffer, or None if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy method to prevent iteration. Do not call.</p>
<p>NOTE(mrry): If we register __getitem__ as an overloaded operator,
Python will valiantly attempt to iterate over the variable’s Tensor from 0
to infinity.  Declaring this method prevents this unintended behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – when invoked.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=False</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedVariable.assign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a new value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – A <cite>Tensor</cite>. The new value for this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the assignment.</p></li>
<li><p><strong>name</strong> – The name to use for the assignment.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.assign_add">
<code class="descname">assign_add</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.assign_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to add to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.assign_sub">
<code class="descname">assign_sub</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.assign_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts a value from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to subtract from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.batch_scatter_update">
<code class="descname">batch_scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.batch_scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable batch-wise.</p>
<p>Analogous to <cite>batch_gather</cite>. This assumes that this variable and the
sparse_delta IndexedSlices have a series of leading dimensions that are the
same for all of them, and the updates are performed on the last dimension of
indices. In other words, the dimensions should be the following:</p>
<p><cite>num_prefix_dims = sparse_delta.indices.ndims - 1</cite>
<cite>batch_dim = num_prefix_dims + 1</cite>
<a href="#id145"><span class="problematic" id="id146">`</span></a>sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[</p>
<blockquote>
<div><p>batch_dim:]`</p>
</div></blockquote>
<p>where</p>
<p><cite>sparse_delta.updates.shape[:num_prefix_dims]</cite>
<cite>== sparse_delta.indices.shape[:num_prefix_dims]</cite>
<cite>== var.shape[:num_prefix_dims]</cite></p>
<p>And the operation performed can be expressed as:</p>
<dl class="simple">
<dt><a href="#id147"><span class="problematic" id="id148">`</span></a>var[i_1, …, i_n,</dt><dd><dl class="simple">
<dt>sparse_delta.indices[i_1, …, i_n, j]] = sparse_delta.updates[</dt><dd><p>i_1, …, i_n, j]`</p>
</dd>
</dl>
</dd>
</dl>
<p>When sparse_delta.indices is a 1D tensor, this operation is equivalent to
<cite>scatter_update</cite>.</p>
<p>To avoid this operation one can looping over the first <cite>ndims</cite> of the
variable and using <cite>scatter_update</cite> on the subtensors that result of slicing
the first dimension. This is a valid option for <cite>ndims = 1</cite>, but less
efficient than this implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.constraint">
<code class="descname">constraint</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the constraint function associated with this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint function that was passed to the variable constructor.
Can be <cite>None</cite> if no constraint was passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.count_up_to">
<code class="descname">count_up_to</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.count_up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments this variable until it reaches <cite>limit</cite>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Prefer Dataset.range instead.</p>
<p>When that Op is run it tries to increment the variable by <cite>1</cite>. If
incrementing the variable would bring it above <cite>limit</cite> then the Op raises
the exception <cite>OutOfRangeError</cite>.</p>
<p>If no error is raised, the Op outputs the value of the variable before
the increment.</p>
<p>This is essentially a shortcut for <cite>count_up_to(self, limit)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>limit</strong> – value at which incrementing the variable raises an error.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the variable value before the increment. If no
other Op modifies this variable, the values produced will all be
distinct.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.create">
<code class="descname">create</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.create" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.device">
<code class="descname">device</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The device this variable is on.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and returns the value of this variable.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.ComposedVariable.from_proto">
<em class="property">static </em><code class="descname">from_proto</code><span class="sig-paren">(</span><em>variable_def</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.from_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>Variable</cite> object created from <cite>variable_def</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of Variable.shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.graph">
<code class="descname">graph</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Graph</cite> of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.handle">
<code class="descname">handle</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle by which this variable can be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.initial_value">
<code class="descname">initial_value</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Tensor used as the initial value for the variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.initialized_value">
<code class="descname">initialized_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.initialized_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the initialized variable.</p>
<p>You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">'v'</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">random</span> <span class="pre">tensor.</span>
<span class="pre">v</span> <span class="pre">=</span> <span class="pre">tf.Variable(tf.truncated_normal([10,</span> <span class="pre">40]))</span>
<span class="pre">#</span> <span class="pre">Use</span> <span class="pre">`initialized_value`</span> <span class="pre">to</span> <span class="pre">guarantee</span> <span class="pre">that</span> <span class="pre">`v`</span> <span class="pre">has</span> <span class="pre">been</span>
<span class="pre">#</span> <span class="pre">initialized</span> <span class="pre">before</span> <span class="pre">its</span> <span class="pre">value</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">initialize</span> <span class="pre">`w`.</span>
<span class="pre">#</span> <span class="pre">The</span> <span class="pre">random</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">picked</span> <span class="pre">only</span> <span class="pre">once.</span>
<span class="pre">w</span> <span class="pre">=</span> <span class="pre">tf.Variable(v.initialized_value()</span> <span class="pre">*</span> <span class="pre">2.0)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Tensor</cite> holding the value of this variable after its initializer
has run.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.is_initialized">
<code class="descname">is_initialized</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.is_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a resource variable has been initialized.</p>
<p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – A name for the operation (optional).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> of type <cite>bool</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>value</em>, <em>session=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedVariable.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load new value into this variable.</p>
<p>Writes new value to variable’s memory. Doesn’t add ops to the graph.</p>
<p>This convenience method requires a session where the graph
containing this variable has been launched. If no session is
passed, the default session is used.  See <cite>tf.Session</cite> for more
information on launching a graph and on sessions.</p>
<p><a href="#id149"><span class="problematic" id="id150">``</span></a><a href="#id151"><span class="problematic" id="id152">`</span></a>python
v = tf.Variable([1, 2])
init = tf.global_variables_initializer()</p>
<dl class="simple">
<dt>with tf.Session() as sess:</dt><dd><p>sess.run(init)
# Usage passing the session explicitly.
v.load([2, 3], sess)
print(v.eval(sess)) # prints [2 3]
# Usage with the default session.  The ‘with’ block
# above makes ‘sess’ the default session.
v.load([3, 4], sess)
print(v.eval()) # prints [3 4]</p>
</dd>
</dl>
<p><a href="#id153"><span class="problematic" id="id154">``</span></a><a href="#id155"><span class="problematic" id="id156">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – New variable value</p></li>
<li><p><strong>session</strong> – The session to use to evaluate this variable. If
none, the default session is used.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – Session is not passed and no default session</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the handle for this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.numpy">
<code class="descname">numpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.op">
<code class="descname">op</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The op for this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.read_value">
<code class="descname">read_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedVariable.read_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.read_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an op which reads the value of this variable.</p>
<p>Should be used when there are multiple reads, or when it is desirable to
read the value only after some condition is true.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the read operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.scatter_add">
<code class="descname">scatter_add</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.scatter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be added to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.scatter_nd_add">
<code class="descname">scatter_nd_add</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.scatter_nd_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse addition to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id157"><span class="problematic" id="id158">``</span></a><a href="#id159"><span class="problematic" id="id160">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
add = ref.scatter_nd_add(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(add)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id161"><span class="problematic" id="id162">``</span></a><a href="#id163"><span class="problematic" id="id164">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 13, 3, 14, 14, 6, 7, 20]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.scatter_nd_sub">
<code class="descname">scatter_nd_sub</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.scatter_nd_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse subtraction to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id165"><span class="problematic" id="id166">``</span></a><a href="#id167"><span class="problematic" id="id168">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_sub(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id169"><span class="problematic" id="id170">``</span></a><a href="#id171"><span class="problematic" id="id172">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, -9, 3, -6, -6, 6, 7, -4]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.scatter_nd_update">
<code class="descname">scatter_nd_update</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.scatter_nd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse assignment to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id173"><span class="problematic" id="id174">``</span></a><a href="#id175"><span class="problematic" id="id176">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_update(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id177"><span class="problematic" id="id178">``</span></a><a href="#id179"><span class="problematic" id="id180">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 11, 3, 10, 9, 6, 7, 12]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.scatter_sub">
<code class="descname">scatter_sub</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.scatter_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be subtracted from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.scatter_update">
<code class="descname">scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.set_shape">
<code class="descname">set_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.set_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.shape">
<code class="descname">shape</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.sparse_read">
<code class="descname">sparse_read</code><span class="sig-paren">(</span><em>indices</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.sparse_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the value of this variable sparsely, using <cite>gather</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a <cite>ResourceVariable</cite> to a <cite>VariableDef</cite> protocol buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><strong>RuntimeError</strong></a> – If run in EAGER mode.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>VariableDef</cite> protocol buffer, or <cite>None</cite> if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ComposedVariable.trainable">
<code class="descname">trainable</code><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ComposedVariable.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ComposedVariable.value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ComposedVariable.value" title="Permalink to this definition">¶</a></dt>
<dd><p>A cached operation which reads the value of this variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.MetaBaseParameter">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">MetaBaseParameter</code><a class="reference internal" href="../_modules/zfit/core/parameter.html#MetaBaseParameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.MetaBaseParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.variables.VariableMetaclass</span></code>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
<dl class="method">
<dt id="zfit.core.parameter.MetaBaseParameter.mro">
<code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.MetaBaseParameter.mro" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a type’s method resolution order.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.Parameter">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">Parameter</code><span class="sig-paren">(</span><em>name</em>, <em>value</em>, <em>lower_limit=None</em>, <em>upper_limit=None</em>, <em>step_size=None</em>, <em>floating=True</em>, <em>dtype=tf.float64</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#Parameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.Parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="zfit.util.execution.html#zfit.util.execution.SessionHolderMixin" title="zfit.util.execution.SessionHolderMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.util.execution.SessionHolderMixin</span></code></a>, <a class="reference internal" href="#zfit.core.parameter.ZfitParameterMixin" title="zfit.core.parameter.ZfitParameterMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.ZfitParameterMixin</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.resource_variable_ops.ResourceVariable</span></code>, <a class="reference internal" href="#zfit.core.parameter.BaseParameter" title="zfit.core.parameter.BaseParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.parameter.BaseParameter</span></code></a></p>
<p>Class for fit parameters, derived from TF Variable class.</p>
<dl class="simple">
<dt>Constructor.</dt><dd><p>name : name of the parameter,
value : starting value
lower_limit : lower limit
upper_limit : upper limit
step_size : step size (set to 0 for fixed parameters)</p>
</dd>
</dl>
<dl class="class">
<dt id="zfit.core.parameter.Parameter.SaveSliceInfo">
<em class="property">class </em><code class="descname">SaveSliceInfo</code><span class="sig-paren">(</span><em>full_name=None</em>, <em>full_shape=None</em>, <em>var_offset=None</em>, <em>var_shape=None</em>, <em>save_slice_info_def=None</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.SaveSliceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Information on how to save this Variable as a slice.</p>
<p>Provides internal support for saving variables as slices of a larger
variable.  This API is not public and is subject to change.</p>
<p>Available properties:</p>
<ul class="simple">
<li><p>full_name</p></li>
<li><p>full_shape</p></li>
<li><p>var_offset</p></li>
<li><p>var_shape</p></li>
</ul>
<p>Create a <cite>SaveSliceInfo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_name</strong> – Name of the full variable of which this <cite>Variable</cite> is a
slice.</p></li>
<li><p><strong>full_shape</strong> – Shape of the full variable, as a list of int.</p></li>
<li><p><strong>var_offset</strong> – Offset of this <cite>Variable</cite> into the full variable, as a
list of int.</p></li>
<li><p><strong>var_shape</strong> – Shape of this <cite>Variable</cite>, as a list of int.</p></li>
<li><p><strong>save_slice_info_def</strong> – <cite>SaveSliceInfoDef</cite> protocol buffer. If not <cite>None</cite>,
recreates the SaveSliceInfo object its contents.
<cite>save_slice_info_def</cite> and other arguments are mutually
exclusive.</p></li>
<li><p><strong>import_scope</strong> – Optional <cite>string</cite>. Name scope to add. Only used
when initializing from protocol buffer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.SaveSliceInfo.spec">
<code class="descname">spec</code><a class="headerlink" href="#zfit.core.parameter.Parameter.SaveSliceInfo.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the spec string used for saving.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.SaveSliceInfo.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.SaveSliceInfo.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SaveSliceInfoDef() proto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>SaveSliceInfoDef</cite> protocol buffer, or None if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy method to prevent iteration. Do not call.</p>
<p>NOTE(mrry): If we register __getitem__ as an overloaded operator,
Python will valiantly attempt to iterate over the variable’s Tensor from 0
to infinity.  Declaring this method prevents this unintended behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – when invoked.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.add_cache_dependents">
<code class="descname">add_cache_dependents</code><span class="sig-paren">(</span><em>cache_dependents: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]], allow_non_cachable: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.add_cache_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dependents that render the cache invalid if they change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cache_dependents</strong> (<a class="reference internal" href="zfit.util.cache.html#zfit.util.cache.ZfitCachable" title="zfit.util.cache.ZfitCachable"><em>ZfitCachable</em></a>) – </p></li>
<li><p><strong>allow_non_cachable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, allow <cite>cache_dependents</cite> to be non-cachables.
If <cite>False</cite>, any <cite>cache_dependents</cite> that is not a <cite>ZfitCachable</cite> will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – if one of the <cite>cache_dependents</cite> is not a <cite>ZfitCachable</cite> _and_ <cite>allow_non_cachable</cite>
    if <cite>False</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a new value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – A <cite>Tensor</cite>. The new value for this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the assignment.</p></li>
<li><p><strong>name</strong> – The name to use for the assignment.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.assign_add">
<code class="descname">assign_add</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.assign_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a value to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to add to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.assign_sub">
<code class="descname">assign_sub</code><span class="sig-paren">(</span><em>delta</em>, <em>use_locking=None</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.assign_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts a value from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delta</strong> – A <cite>Tensor</cite>. The value to subtract from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – The name to use for the operation.</p></li>
<li><p><strong>read_value</strong> – A <cite>bool</cite>. Whether to read and return the new value of the
variable or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>read_value</cite> is <cite>True</cite>, this method will return the new value of the
variable after the assignment has completed. Otherwise, when in graph mode
it will return the <cite>Operation</cite> that does the assignment, and when in eager
mode it will return <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.batch_scatter_update">
<code class="descname">batch_scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.batch_scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable batch-wise.</p>
<p>Analogous to <cite>batch_gather</cite>. This assumes that this variable and the
sparse_delta IndexedSlices have a series of leading dimensions that are the
same for all of them, and the updates are performed on the last dimension of
indices. In other words, the dimensions should be the following:</p>
<p><cite>num_prefix_dims = sparse_delta.indices.ndims - 1</cite>
<cite>batch_dim = num_prefix_dims + 1</cite>
<a href="#id181"><span class="problematic" id="id182">`</span></a>sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[</p>
<blockquote>
<div><p>batch_dim:]`</p>
</div></blockquote>
<p>where</p>
<p><cite>sparse_delta.updates.shape[:num_prefix_dims]</cite>
<cite>== sparse_delta.indices.shape[:num_prefix_dims]</cite>
<cite>== var.shape[:num_prefix_dims]</cite></p>
<p>And the operation performed can be expressed as:</p>
<dl class="simple">
<dt><a href="#id183"><span class="problematic" id="id184">`</span></a>var[i_1, …, i_n,</dt><dd><dl class="simple">
<dt>sparse_delta.indices[i_1, …, i_n, j]] = sparse_delta.updates[</dt><dd><p>i_1, …, i_n, j]`</p>
</dd>
</dl>
</dd>
</dl>
<p>When sparse_delta.indices is a 1D tensor, this operation is equivalent to
<cite>scatter_update</cite>.</p>
<p>To avoid this operation one can looping over the first <cite>ndims</cite> of the
variable and using <cite>scatter_update</cite> on the subtensors that result of slicing
the first dimension. This is a valid option for <cite>ndims = 1</cite>, but less
efficient than this implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.constraint">
<code class="descname">constraint</code><a class="headerlink" href="#zfit.core.parameter.Parameter.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the constraint function associated with this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint function that was passed to the variable constructor.
Can be <cite>None</cite> if no constraint was passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep: bool = False</em>, <em>name: str = None</em>, <em>**overwrite_params</em><span class="sig-paren">)</span> &#x2192; zfit.core.interfaces.ZfitObject<a class="headerlink" href="#zfit.core.parameter.Parameter.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.count_up_to">
<code class="descname">count_up_to</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.count_up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments this variable until it reaches <cite>limit</cite>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Prefer Dataset.range instead.</p>
<p>When that Op is run it tries to increment the variable by <cite>1</cite>. If
incrementing the variable would bring it above <cite>limit</cite> then the Op raises
the exception <cite>OutOfRangeError</cite>.</p>
<p>If no error is raised, the Op outputs the value of the variable before
the increment.</p>
<p>This is essentially a shortcut for <cite>count_up_to(self, limit)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>limit</strong> – value at which incrementing the variable raises an error.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the variable value before the increment. If no
other Op modifies this variable, the values produced will all be
distinct.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.create">
<code class="descname">create</code><a class="headerlink" href="#zfit.core.parameter.Parameter.create" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.device">
<code class="descname">device</code><a class="headerlink" href="#zfit.core.parameter.Parameter.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The device this variable is on.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.Parameter.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the object</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and returns the value of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.floating">
<code class="descname">floating</code><a class="headerlink" href="#zfit.core.parameter.Parameter.floating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="zfit.core.parameter.Parameter.from_proto">
<em class="property">static </em><code class="descname">from_proto</code><span class="sig-paren">(</span><em>variable_def</em>, <em>import_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.from_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>Variable</cite> object created from <cite>variable_def</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.get_dependents">
<code class="descname">get_dependents</code><span class="sig-paren">(</span><em>only_floating: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[zfit.core.parameter.Parameter]<a class="headerlink" href="#zfit.core.parameter.Parameter.get_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of all independent <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> that this object depends on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>only_floating</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, only return floating <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>only_floating: bool = False, names: Union[str, List[str], None] = None</em><span class="sig-paren">)</span> &#x2192; List[zfit.core.interfaces.ZfitParameter]<a class="headerlink" href="#zfit.core.parameter.Parameter.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters. If it is empty, automatically return all floating variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>)</strong> (<em>names</em>) – If True, return only the floating parameters.</p></li>
<li><p><strong>(</strong><strong>)</strong> – The names of the parameters to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(<cite>ZfitParameters</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of Variable.shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.graph">
<code class="descname">graph</code><a class="headerlink" href="#zfit.core.parameter.Parameter.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Graph</cite> of this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.handle">
<code class="descname">handle</code><a class="headerlink" href="#zfit.core.parameter.Parameter.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle by which this variable can be accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.has_limits">
<code class="descname">has_limits</code><a class="headerlink" href="#zfit.core.parameter.Parameter.has_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.independent">
<code class="descname">independent</code><a class="headerlink" href="#zfit.core.parameter.Parameter.independent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.initial_value">
<code class="descname">initial_value</code><a class="headerlink" href="#zfit.core.parameter.Parameter.initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Tensor used as the initial value for the variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.initialized_value">
<code class="descname">initialized_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.initialized_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the initialized variable.</p>
<p>You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">'v'</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">random</span> <span class="pre">tensor.</span>
<span class="pre">v</span> <span class="pre">=</span> <span class="pre">tf.Variable(tf.truncated_normal([10,</span> <span class="pre">40]))</span>
<span class="pre">#</span> <span class="pre">Use</span> <span class="pre">`initialized_value`</span> <span class="pre">to</span> <span class="pre">guarantee</span> <span class="pre">that</span> <span class="pre">`v`</span> <span class="pre">has</span> <span class="pre">been</span>
<span class="pre">#</span> <span class="pre">initialized</span> <span class="pre">before</span> <span class="pre">its</span> <span class="pre">value</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">initialize</span> <span class="pre">`w`.</span>
<span class="pre">#</span> <span class="pre">The</span> <span class="pre">random</span> <span class="pre">values</span> <span class="pre">are</span> <span class="pre">picked</span> <span class="pre">only</span> <span class="pre">once.</span>
<span class="pre">w</span> <span class="pre">=</span> <span class="pre">tf.Variable(v.initialized_value()</span> <span class="pre">*</span> <span class="pre">2.0)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Tensor</cite> holding the value of this variable after its initializer
has run.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#zfit.core.parameter.Parameter.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>The op responsible for initializing this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.is_initialized">
<code class="descname">is_initialized</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.is_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a resource variable has been initialized.</p>
<p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – A name for the operation (optional).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> of type <cite>bool</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>value: Union[int, float, complex, tensorflow.python.framework.ops.Tensor]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#Parameter.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.Parameter.load" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> takes on the <cite>value</cite>. Is not part of the graph, does a session run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>numerical</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.lower_limit">
<code class="descname">lower_limit</code><a class="headerlink" href="#zfit.core.parameter.Parameter.lower_limit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.Parameter.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the object.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.numpy">
<code class="descname">numpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.op">
<code class="descname">op</code><a class="headerlink" href="#zfit.core.parameter.Parameter.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The op for this variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.params">
<code class="descname">params</code><a class="headerlink" href="#zfit.core.parameter.Parameter.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.randomize">
<code class="descname">randomize</code><span class="sig-paren">(</span><em>minval=None</em>, <em>maxval=None</em>, <em>sampler=&lt;built-in method uniform of mtrand.RandomState object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#Parameter.randomize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.Parameter.randomize" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the value with a randomised value between minval and maxval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minval</strong> (<em>Numerical</em>) – </p></li>
<li><p><strong>maxval</strong> (<em>Numerical</em>) – </p></li>
<li><p><strong>(</strong><strong>)</strong> (<em>sampler</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.read_value">
<code class="descname">read_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#Parameter.read_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.Parameter.read_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an op which reads the value of this variable.</p>
<p>Should be used when there are multiple reads, or when it is desirable to
read the value only after some condition is true.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the read operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.register_cacher">
<code class="descname">register_cacher</code><span class="sig-paren">(</span><em>cacher: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]]</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.register_cacher" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <cite>cacher</cite> that caches values produces by this instance; a dependent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>)</strong> (<em>cacher</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.reset_cache">
<code class="descname">reset_cache</code><span class="sig-paren">(</span><em>reseter: zfit.util.cache.ZfitCachable</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.reset_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.reset_cache_self">
<code class="descname">reset_cache_self</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.reset_cache_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache of self and all dependent cachers.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.scatter_add">
<code class="descname">scatter_add</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.scatter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be added to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.scatter_nd_add">
<code class="descname">scatter_nd_add</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.scatter_nd_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse addition to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id185"><span class="problematic" id="id186">``</span></a><a href="#id187"><span class="problematic" id="id188">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
add = ref.scatter_nd_add(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(add)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id189"><span class="problematic" id="id190">``</span></a><a href="#id191"><span class="problematic" id="id192">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 13, 3, 14, 14, 6, 7, 20]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.scatter_nd_sub">
<code class="descname">scatter_nd_sub</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.scatter_nd_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse subtraction to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id193"><span class="problematic" id="id194">``</span></a><a href="#id195"><span class="problematic" id="id196">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_sub(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id197"><span class="problematic" id="id198">``</span></a><a href="#id199"><span class="problematic" id="id200">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, -9, 3, -6, -6, 6, 7, -4]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.scatter_nd_update">
<code class="descname">scatter_nd_update</code><span class="sig-paren">(</span><em>indices</em>, <em>updates</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.scatter_nd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sparse assignment to individual values or slices in a Variable.</p>
<p><cite>ref</cite> is a <cite>Tensor</cite> with rank <cite>P</cite> and <cite>indices</cite> is a <cite>Tensor</cite> of rank <cite>Q</cite>.</p>
<p><cite>indices</cite> must be integer tensor, containing indices into <cite>ref</cite>.
It must be shape <cite>[d_0, …, d_{Q-2}, K]</cite> where <cite>0 &lt; K &lt;= P</cite>.</p>
<p>The innermost dimension of <cite>indices</cite> (with length <cite>K</cite>) corresponds to
indices into elements (if <cite>K = P</cite>) or slices (if <cite>K &lt; P</cite>) along the <cite>K`th
dimension of `ref</cite>.</p>
<p><cite>updates</cite> is <cite>Tensor</cite> of rank <cite>Q-1+P-K</cite> with shape:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[d_0,</span> <span class="pre">...,</span> <span class="pre">d_{Q-2},</span> <span class="pre">ref.shape[K],</span> <span class="pre">...,</span> <span class="pre">ref.shape[P-1]].</span>
<span class="pre">`</span></code></p>
<p>For example, say we want to add 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:</p>
<dl>
<dt><a href="#id201"><span class="problematic" id="id202">``</span></a><a href="#id203"><span class="problematic" id="id204">`</span></a>python</dt><dd><p>ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1] ,[7]])
updates = tf.constant([9, 10, 11, 12])
op = ref.scatter_nd_update(indices, updates)
with tf.Session() as sess:</p>
<blockquote>
<div><p>print sess.run(op)</p>
</div></blockquote>
</dd>
</dl>
<p><a href="#id205"><span class="problematic" id="id206">``</span></a><a href="#id207"><span class="problematic" id="id208">`</span></a></p>
<p>The resulting update to ref would look like this:</p>
<blockquote>
<div><p>[1, 11, 3, 10, 9, 6, 7, 12]</p>
</div></blockquote>
<p>See <cite>tf.scatter_nd</cite> for more details about how to make updates to
slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – The indices to be used in the operation.</p></li>
<li><p><strong>updates</strong> – The values to be used in the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.scatter_sub">
<code class="descname">scatter_sub</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.scatter_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts <cite>IndexedSlices</cite> from this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be subtracted from this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.scatter_update">
<code class="descname">scatter_update</code><span class="sig-paren">(</span><em>sparse_delta</em>, <em>use_locking=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.scatter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns <cite>IndexedSlices</cite> to this variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse_delta</strong> – <cite>IndexedSlices</cite> to be assigned to this variable.</p></li>
<li><p><strong>use_locking</strong> – If <cite>True</cite>, use locking during the operation.</p></li>
<li><p><strong>name</strong> – the name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Tensor</cite> that will hold the new value of this variable after
the scattered subtraction has completed.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><strong>ValueError</strong></a> – if <cite>sparse_delta</cite> is not an <cite>IndexedSlices</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.sess">
<code class="descname">sess</code><a class="headerlink" href="#zfit.core.parameter.Parameter.sess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.set_sess">
<code class="descname">set_sess</code><span class="sig-paren">(</span><em>sess: tensorflow.python.client.session.Session</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.set_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the session (temporarily) for this instance. If None, the auto-created default is taken.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sess</strong> (<em>tf.Session</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.set_shape">
<code class="descname">set_shape</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.set_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.set_value">
<code class="descname">set_value</code><span class="sig-paren">(</span><em>value: Union[int, float, complex, tensorflow.python.framework.ops.Tensor]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#Parameter.set_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.Parameter.set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> to <cite>value</cite> (temporarily if used in a context manager).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The value the parameter will take on.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.shape">
<code class="descname">shape</code><a class="headerlink" href="#zfit.core.parameter.Parameter.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this variable.</p>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.sparse_read">
<code class="descname">sparse_read</code><span class="sig-paren">(</span><em>indices</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.sparse_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the value of this variable sparsely, using <cite>gather</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.step_size">
<code class="descname">step_size</code><a class="headerlink" href="#zfit.core.parameter.Parameter.step_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.to_proto">
<code class="descname">to_proto</code><span class="sig-paren">(</span><em>export_scope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.Parameter.to_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a <cite>ResourceVariable</cite> to a <cite>VariableDef</cite> protocol buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>export_scope</strong> – Optional <cite>string</cite>. Name scope to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><strong>RuntimeError</strong></a> – If run in EAGER mode.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>VariableDef</cite> protocol buffer, or <cite>None</cite> if the <cite>Variable</cite> is not
in the specified name scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.trainable">
<code class="descname">trainable</code><a class="headerlink" href="#zfit.core.parameter.Parameter.trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.Parameter.upper_limit">
<code class="descname">upper_limit</code><a class="headerlink" href="#zfit.core.parameter.Parameter.upper_limit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.Parameter.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#Parameter.value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.Parameter.value" title="Permalink to this definition">¶</a></dt>
<dd><p>A cached operation which reads the value of this variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.ZfitBaseVariable">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">ZfitBaseVariable</code><span class="sig-paren">(</span><em>variable: tensorflow.python.ops.variables.VariableV1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ZfitBaseVariable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ZfitBaseVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="zfit.core.parameter.ZfitBaseVariable.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>value</em>, <em>use_locking=False</em>, <em>name=None</em>, <em>read_value=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ZfitBaseVariable.assign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ZfitBaseVariable.assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ZfitBaseVariable.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.ZfitBaseVariable.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitBaseVariable.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ZfitBaseVariable.value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ZfitBaseVariable.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="zfit.core.parameter.ZfitParameterMixin">
<em class="property">class </em><code class="descclassname">zfit.core.parameter.</code><code class="descname">ZfitParameterMixin</code><span class="sig-paren">(</span><em>name</em>, <em>initial_value</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#ZfitParameterMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="zfit.core.baseobject.html#zfit.core.baseobject.BaseNumeric" title="zfit.core.baseobject.BaseNumeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">zfit.core.baseobject.BaseNumeric</span></code></a></p>
<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.add_cache_dependents">
<code class="descname">add_cache_dependents</code><span class="sig-paren">(</span><em>cache_dependents: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]], allow_non_cachable: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.add_cache_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dependents that render the cache invalid if they change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cache_dependents</strong> (<a class="reference internal" href="zfit.util.cache.html#zfit.util.cache.ZfitCachable" title="zfit.util.cache.ZfitCachable"><em>ZfitCachable</em></a>) – </p></li>
<li><p><strong>allow_non_cachable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, allow <cite>cache_dependents</cite> to be non-cachables.
If <cite>False</cite>, any <cite>cache_dependents</cite> that is not a <cite>ZfitCachable</cite> will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><strong>TypeError</strong></a> – if one of the <cite>cache_dependents</cite> is not a <cite>ZfitCachable</cite> _and_ <cite>allow_non_cachable</cite>
    if <cite>False</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep: bool = False</em>, <em>name: str = None</em>, <em>**overwrite_params</em><span class="sig-paren">)</span> &#x2192; zfit.core.interfaces.ZfitObject<a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ZfitParameterMixin.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the object</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ZfitParameterMixin.floating">
<code class="descname">floating</code><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.floating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.get_dependents">
<code class="descname">get_dependents</code><span class="sig-paren">(</span><em>only_floating: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[zfit.core.parameter.Parameter]<a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.get_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of all independent <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> that this object depends on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>only_floating</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If <cite>True</cite>, only return floating <a class="reference internal" href="zfit.html#zfit.Parameter" title="zfit.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>only_floating: bool = False, names: Union[str, List[str], None] = None</em><span class="sig-paren">)</span> &#x2192; List[zfit.core.interfaces.ZfitParameter]<a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters. If it is empty, automatically return all floating variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>)</strong> (<em>names</em>) – If True, return only the floating parameters.</p></li>
<li><p><strong>(</strong><strong>)</strong> – The names of the parameters to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(<cite>ZfitParameters</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ZfitParameterMixin.name">
<code class="descname">name</code><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="zfit.core.parameter.ZfitParameterMixin.params">
<code class="descname">params</code><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.register_cacher">
<code class="descname">register_cacher</code><span class="sig-paren">(</span><em>cacher: Union[zfit.core.interfaces.ZfitCachable, Iterable[zfit.core.interfaces.ZfitCachable]]</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.register_cacher" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <cite>cacher</cite> that caches values produces by this instance; a dependent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>)</strong> (<em>cacher</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.reset_cache">
<code class="descname">reset_cache</code><span class="sig-paren">(</span><em>reseter: zfit.util.cache.ZfitCachable</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.reset_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zfit.core.parameter.ZfitParameterMixin.reset_cache_self">
<code class="descname">reset_cache_self</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.ZfitParameterMixin.reset_cache_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache of self and all dependent cachers.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="zfit.core.parameter.convert_to_parameter">
<code class="descclassname">zfit.core.parameter.</code><code class="descname">convert_to_parameter</code><span class="sig-paren">(</span><em>value</em>, <em>name=None</em>, <em>prefer_floating=False</em><span class="sig-paren">)</span> &#x2192; zfit.core.interfaces.ZfitParameter<a class="reference internal" href="../_modules/zfit/core/parameter.html#convert_to_parameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.convert_to_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a <em>numerical</em> to a fixed parameter or return if already a parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>)</strong> (<em>value</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="zfit.core.parameter.feed_function">
<code class="descclassname">zfit.core.parameter.</code><code class="descname">feed_function</code><span class="sig-paren">(</span><em>feed</em>, <em>feed_val</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.feed_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="zfit.core.parameter.feed_function_for_partial_run">
<code class="descclassname">zfit.core.parameter.</code><code class="descname">feed_function_for_partial_run</code><span class="sig-paren">(</span><em>feed</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.feed_function_for_partial_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="zfit.core.parameter.fetch_function">
<code class="descclassname">zfit.core.parameter.</code><code class="descname">fetch_function</code><span class="sig-paren">(</span><em>variable</em><span class="sig-paren">)</span><a class="headerlink" href="#zfit.core.parameter.fetch_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="zfit.core.parameter.get_auto_number">
<code class="descclassname">zfit.core.parameter.</code><code class="descname">get_auto_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/zfit/core/parameter.html#get_auto_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#zfit.core.parameter.get_auto_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright Copyright 2018, zfit.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>